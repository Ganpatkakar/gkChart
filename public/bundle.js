/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const printOpts = __webpack_require__(/*! ./src/common/print_options */ \"./src/common/print_options.js\");\nconst printOptions = printOpts.printOptions;\nconst printAction = printOpts.printAction;\nconst ChartSurface = __webpack_require__(/*! ./src/common/chart_surface */ \"./src/common/chart_surface.js\");\nconst Grids = __webpack_require__(/*! ./src/common/grid */ \"./src/common/grid.js\");\nconst drawGrid = Grids.drawGrid;\nconst drawGraphicLinearYcord = Grids.drawGraphicLinearYcord;\n\nconst newGrids = __webpack_require__(/*! ./src/common/grid_new */ \"./src/common/grid_new.js\");\nconst drawNewGrid = newGrids.drawGridNew;\nconst drawNewGraphicLinearYCord = newGrids.drawNewGraphicLinearYCord;\n\nconst verticalGrids = __webpack_require__(/*! ./src/common/vertical-grid */ \"./src/common/vertical-grid.js\");\nconst drawVerticalGrid = verticalGrids.drawVerticalGrid;\nconst drawDocumentationDetails = verticalGrids.drawDocumentationDetails;\nconst drawLineChart = __webpack_require__(/*! ./src/common/drawChart/line_chart_canvas */ \"./src/common/drawChart/line_chart_canvas.js\");\nconst LineChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/line_chart_upper_canvas */ \"./src/common/drawUpperChart/line_chart_upper_canvas.js\");\nconst ClearDetails = __webpack_require__(/*! ./src/common/drawUpperChart/clear_upper_canvas_details */ \"./src/common/drawUpperChart/clear_upper_canvas_details.js\");\nconst DrawStepChart = __webpack_require__(/*! ./src/common/drawChart/step_chart_canvas */ \"./src/common/drawChart/step_chart_canvas.js\");\nconst drawSmoothLineChart = __webpack_require__(/*! ./src/common/drawChart/smooth_line_chart_canvas */ \"./src/common/drawChart/smooth_line_chart_canvas.js\");\nconst drawBarChart = __webpack_require__(/*! ./src/common/drawChart/bar_chart_canvas */ \"./src/common/drawChart/bar_chart_canvas.js\");\nconst drawColumnChart = __webpack_require__(/*! ./src/common/drawChart/column_chart_canvas */ \"./src/common/drawChart/column_chart_canvas.js\");\nconst drawStackedChart = __webpack_require__(/*! ./src/common/drawChart/stacked_chart_canvas */ \"./src/common/drawChart/stacked_chart_canvas.js\");\nconst BarChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/bar_chart_upper_canvas */ \"./src/common/drawUpperChart/bar_chart_upper_canvas.js\");\nconst columnChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/column_chart_upper_canvas */ \"./src/common/drawUpperChart/column_chart_upper_canvas.js\");\nconst stackedChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/stacked_chart_upper_canvas */ \"./src/common/drawUpperChart/stacked_chart_upper_canvas.js\");\nconst drawPieChart = __webpack_require__(/*! ./src/common/drawChart/pie_chart_canvas */ \"./src/common/drawChart/pie_chart_canvas.js\");\nconst PieChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/pie_chart_upper_canvas */ \"./src/common/drawUpperChart/pie_chart_upper_canvas.js\");\nconst drawDoughnutChart = __webpack_require__(/*! ./src/common/drawChart/doughnut_chart_canvas */ \"./src/common/drawChart/doughnut_chart_canvas.js\");\nconst DoughnutChartUpperCanvas = __webpack_require__(/*! ./src/common/drawUpperChart/doughnut_chart_upper_canvas */ \"./src/common/drawUpperChart/doughnut_chart_upper_canvas.js\");\nconst drawMeterChart = __webpack_require__(/*! ./src/common/drawChart/meter_chart_canvas */ \"./src/common/drawChart/meter_chart_canvas.js\");\nconst drawStackedBarChart = __webpack_require__(/*! ./src/common/drawChart/stacked_bar_chart_canvas */ \"./src/common/drawChart/stacked_bar_chart_canvas.js\");\n\nconst calcTextWidth = __webpack_require__(/*! ./src/common/calc-text-width */ \"./src/common/calc-text-width.js\");\n\nconst enums = __webpack_require__(/*! ./src/invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst GkLineChart = data => {\n    try {\n        // console.log(\"Start : lineChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        chart.yaxis === undefined ? chart.yaxis = {} : null;\n        if (!chart.yaxis.hasOwnProperty(\"max\") || !chart.yaxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].y);\n            let min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            if (!chart.yaxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.yaxis.max = max + extraAddition;\n            }\n            if (!chart.yaxis.hasOwnProperty(\"min\")) {\n                chart.yaxis.min = chart.yaxis.min >= 10 ? min - 10 : min;\n            }\n            console.log(chart.yaxis.max, chart.yaxis.min);\n        }\n        if (!chart.yaxis.numOfRows) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        } else {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.numOfRows);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n\n        let maxTextWidth = 30 + calcTextWidth(chart.data[0].datapoints, ctx_base, \"y\");\n\n        let canvas = 'canvas' + chart.chartnumber;\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data, maxTextWidth);\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart, maxTextWidth);\n        let maxdata = [chart.yaxis.min, chart.yaxis.max];\n        let linecord = [];\n        for (let i = 0; i < chart.data.length; i++) {\n            drawLineChart(canvas, ctx_base, verticaldevisions, chart.data[i], maxdata, chart.data[i].chartColor, linecord);\n        }\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        LineChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n    } catch (err) {\n        console.error(\"Exception occurred in line chart module:  \" + err.message);\n    }\n};\n\nconst GkStepChart = data => {\n    try {\n        // console.log(\"Start : stepChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        chart.yaxis === undefined ? chart.yaxis = {} : null;\n        if (!chart.yaxis.hasOwnProperty(\"max\") || !chart.yaxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].y);\n            let min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            if (!chart.yaxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.yaxis.max = max + extraAddition;\n            }\n            if (!chart.yaxis.hasOwnProperty(\"min\")) {\n                chart.yaxis.min = chart.yaxis.min >= 10 ? min - 10 : min;\n            }\n            console.log(chart.yaxis.max, chart.yaxis.min);\n        }\n        if (!chart.yaxis.numOfRows) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        } else {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.numOfRows);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n\n        let maxTextWidth = 30 + calcTextWidth(chart.data[0].datapoints, ctx_base, \"y\");\n\n        let canvas = 'canvas' + chart.chartnumber;\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data, maxTextWidth);\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart, maxTextWidth);\n\n        let maxdata = [chart.yaxis.min, chart.yaxis.max];\n        let linecord = [];\n        for (let i = 0; i < chart.data.length; i++) {\n            DrawStepChart(canvas, ctx_base, verticaldevisions, chart.data[i], maxdata, chart.data[i].chartColor, linecord, maxTextWidth);\n        }\n\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        LineChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n        // console.log(\"End : stepChart\");\n    } catch (error) {\n        console.log(\"Error Occured while chart calling of step chart\" + error.message);\n    }\n};\n\nconst GkSmoothLineChart = data => {\n    try {\n        // console.log(\"Start : splineChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n\n        chart.yaxis === undefined ? chart.yaxis = {} : null;\n        if (!chart.yaxis.hasOwnProperty(\"max\") || !chart.yaxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].y);\n            let min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            if (!chart.yaxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.yaxis.max = max + extraAddition;\n            }\n            if (!chart.yaxis.hasOwnProperty(\"min\")) {\n                chart.yaxis.min = chart.yaxis.min >= 10 ? min - 10 : min;\n            }\n            console.log(chart.yaxis.max, chart.yaxis.min);\n        }\n        if (!chart.yaxis.numOfRows) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        } else {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.numOfRows);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n\n        let maxTextWidth = 30 + calcTextWidth(chart.data[0].datapoints, ctx_base, \"y\");\n        let canvas = 'canvas' + chart.chartnumber;\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data, maxTextWidth);\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart, maxTextWidth);\n\n        let maxdata = [chart.yaxis.min, chart.yaxis.max];\n        let linecord = [];\n        for (let i = 0; i < chart.data.length; i++) {\n            drawSmoothLineChart(canvas, ctx_base, verticaldevisions, chart.data[i], maxdata, chart.data[i].chartColor, linecord, maxTextWidth);\n        }\n\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        LineChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n        // console.log(\"End : splineChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in line chart module:  \" + err.message);\n    }\n};\n\n//Todo: MAP bar chart properly with the latest data format\n\nconst GkBarChart = data => {\n    try {\n        // console.log(\"Start : barChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        !chart.xAxis ? chart.xAxis = {} : null;\n\n        if (!chart.xAxis.hasOwnProperty(\"max\") || !chart.xAxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].value);\n            let min = max;\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].value) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].value);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].value) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].value);\n                    }\n                }\n            }\n            if (!chart.xAxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.xAxis.max = max + extraAddition;\n            }\n            if (!chart.xAxis.hasOwnProperty(\"min\")) {\n                chart.xAxis.min = chart.xAxis.min >= 10 ? min - 10 : min;\n            }\n        }\n\n        let maxTextWidth = calcTextWidth(chart.categories, ctx_base, \"label\");\n\n        if (!chart.xAxis.numOfRows) {\n            chart.xAxis.difference = (chart.xAxis.max - chart.xAxis.min) / 8;\n        } else {\n            chart.xAxis.difference = (chart.xAxis.max - chart.xAxis.min) / chart.xAxis.numOfRows;\n        }\n\n        let horizontalNr = chart.xAxis.numOfRows ? chart.xAxis.numOfRows : 8;\n        let canvas = 'canvas' + chart.chartnumber;\n        drawVerticalGrid(chart.chartnumber, horizontalNr, ctx_base, chart.data, maxTextWidth);\n        drawDocumentationDetails(canvas, ctx_base, horizontalNr, chart, maxTextWidth);\n        let rangedata = [chart.xAxis.min, chart.xAxis.max];\n        let linecord = [];\n        let nextcurve = 0;\n        let barChartCount = chart.data.length;\n        for (let i = 0; i < chart.data.length; i++) {\n            const barChartProps = {\n                canvas,\n                ctx_base,\n                horizontalNr,\n                data: chart.data[i],\n                categories: chart.categories,\n                rangedata,\n                nextcurve,\n                chartColor: chart.data[i].chartColor,\n                linecord,\n                barChartCount,\n                chartDataLength: chart.data.length,\n                maxTextWidth\n            };\n            const rData = drawBarChart(barChartProps);\n            nextcurve += rData.barHeight + 5;\n        }\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        BarChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n        // console.log(\"End : barChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in bar chart module:  \" + err.message);\n    }\n};\n\nconst GkStackedBarChart = data => {\n    try {\n        // console.log(\"Start : barChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        !chart.xAxis ? chart.xAxis = {} : null;\n\n        const xAxisCount = chart.categories.length;\n        let max = 0;\n        const maxTextWidth = calcTextWidth(chart.categories, ctx_base, \"label\");\n        for (const d of chart.data) {\n            const dataSet = d.dataSet;\n            const dataSetLength = dataSet.length;\n            for (let i = 0; i < xAxisCount; i++) {\n                let sum = 0;\n                for (let j = 0; j < dataSetLength; j++) {\n                    sum = sum + dataSet[j].dataPoints[i].value;\n                }\n                if (sum > max) {\n                    max = sum;\n                }\n            }\n        }\n        max = max < 100 ? max + 5 : max + 10;\n        const canvasId = 'canvas' + chart.chartnumber;\n        let verticalNr = chart.xAxis.rowCount;\n        chart.xAxis.max = max;\n        if (!verticalNr) {\n            verticalNr = 8;\n        }\n\n        // calculate the xAix difference variable\n        chart.xAxis.difference = (max - chart.xAxis.min) / verticalNr;\n\n        drawVerticalGrid(chart.chartnumber, verticalNr, ctx_base, chart, maxTextWidth);\n        drawDocumentationDetails(canvasId, ctx_base, verticalNr, chart, maxTextWidth);\n\n        let range = [chart.xAxis.min, chart.xAxis.max];\n        let barCords = [];\n        let nextCurve = 0;\n        let barChartCount = chart.data.length;\n        for (let i = 0; i < chart.data.length; i++) {\n            const barChartProps = {\n                canvasId,\n                ctx_base,\n                verticalNr,\n                data: chart.data[i],\n                categories: chart.categories,\n                range,\n                nextCurve,\n                chartColor: chart.data[i].chartColor,\n                barCords,\n                barChartCount,\n                chartDataLength: chart.data.length,\n                maxTextWidth,\n                chart,\n                renderCount: i\n            };\n            const rData = drawStackedBarChart(barChartProps);\n            nextCurve += rData.barHeight + 5;\n        }\n        // let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        // ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        // BarChartUpperCanvas(chart.chartnumber, ctx_upper, barCords, chart.container, chart, maxTextWidth);\n        // printAction(chartID, chart);\n        // console.log(\"End : barChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in Stacked bar chart module:  \" + err.message);\n    }\n};\n\nconst GkColumnChart = data => {\n    try {\n        // console.log(\"Start : barChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        !chart.yaxis ? chart.yaxis = {} : null;\n\n        if (!chart.yaxis.hasOwnProperty(\"max\") || !chart.yaxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].y);\n            let min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            if (!chart.yaxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.yaxis.max = max + extraAddition;\n            }\n            if (!chart.yaxis.hasOwnProperty(\"min\")) {\n                chart.yaxis.min = chart.yaxis.min >= 10 ? min - 10 : min;\n            }\n            console.log(chart.yaxis.max, chart.yaxis.min);\n        }\n        if (!chart.yaxis.numOfRows) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        } else {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.numOfRows);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n\n        let maxTextWidth = 30 + calcTextWidth(chart.data[0].datapoints, ctx_base, \"y\");\n        let canvas = 'canvas' + chart.chartnumber;\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data, maxTextWidth);\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart, maxTextWidth);\n\n        let range = [chart.yaxis.min, chart.yaxis.max];\n        let columnCords = [];\n        let nextcurve = 0;\n        let barChartCount = chart.data.length;\n        for (let i = 0; i < chart.data.length; i++) {\n            const props = {\n                canvas,\n                ctx_base,\n                verticaldevisions,\n                data: chart.data[i],\n                range,\n                nextcurve,\n                chartColor: chart.data[i].chartColor,\n                columnCords,\n                columnChartCount: barChartCount,\n                maxTextWidth\n            };\n            const rData = drawColumnChart(props);\n            nextcurve += rData.barwidth + 5;\n        }\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        columnChartUpperCanvas(chart.chartnumber, ctx_upper, columnCords, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n        // console.log(\"End : barChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in bar chart module:  \" + err.message);\n    }\n};\n\nconst GkStackedChart = data => {\n    try {\n        // console.log(\"Start : barChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        !chart.yAxis ? chart.yAxis = {} : null;\n\n        const xAxisCount = chart.categories.length;\n        let max = 0;\n        let maxTextWidth = 0;\n        for (const d of chart.data) {\n            const dataSet = d.dataSet;\n            const dataSetLength = dataSet.length;\n            for (let i = 0; i < xAxisCount; i++) {\n                let sum = 0;\n                for (let j = 0; j < dataSetLength; j++) {\n                    sum = sum + dataSet[j].dataPoints[i].value;\n                }\n                if (sum > max) {\n                    max = sum;\n                }\n                const textWidth = ctx_base.measureText(sum).width;\n                maxTextWidth = textWidth > maxTextWidth ? textWidth : maxTextWidth;\n            }\n        }\n        max = max < 100 ? max + 5 : max + 10;\n        const canvasId = 'canvas' + chart.chartnumber;\n        let verticalNr = chart.yAxis.rowCount;\n        if (!verticalNr) {\n            verticalNr = 8;\n        }\n\n        // calculate the yAix difference variable\n        chart.yAxis.difference = (max - chart.yAxis.min) / verticalNr;\n\n        drawNewGrid(chart.chartnumber, verticalNr, ctx_base, chart, maxTextWidth);\n        drawNewGraphicLinearYCord(canvasId, ctx_base, verticalNr, chart, maxTextWidth);\n\n        let range = [chart.yAxis.min, max];\n        let columnCords = [];\n        let nextCurve = 0;\n        let columnChartCount = chart.data.length;\n        for (let i = 0; i < chart.data.length; i++) {\n            const props = {\n                canvasId,\n                ctx_base,\n                verticalNr,\n                chart,\n                renderCount: i,\n                range,\n                nextCurve,\n                chartColor: chart.data[i].chartColor,\n                columnCords,\n                columnChartCount,\n                maxTextWidth\n            };\n            const rData = drawStackedChart(props);\n            nextCurve += rData.barWidth + 5;\n        }\n        const ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        stackedChartUpperCanvas(chart.chartnumber, ctx_upper, columnCords, chart.container, chart, maxTextWidth);\n        printAction(chartID, chart);\n        console.log(\"End : barChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in bar chart module:  \" + err.message);\n    }\n};\n\nconst GkPieChart = data => {\n    try {\n        // console.log(\"Start : pieChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        var chartContainerSelector = document.querySelector(\"#\" + chart.container);\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.chartnumber = chartID;\n        chart.wid = chartContainerSelector.clientWidth;\n        chart.hei = chartContainerSelector.clientHeight - 33;\n        let chartHeight = chart.hei;\n        if (chart.hei > chart.wid) {\n            chartHeight = chart.wid;\n        }\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += `<h2 class=\"chartTitle\">${chart.config.title}</h2>`;\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chartHeight, chart.container);\n        let canvas = 'canvas' + chart.chartnumber;\n        var linecord = [];\n        for (var i = 0; i < chart.data.length; i++) {\n            drawPieChart(canvas, ctx_base, chart.data[i], linecord);\n        }\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chartHeight, chart.container);\n        PieChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container);\n\n        let pieChartDataDisplay = '<ul style=\"list-style: none; width: ' + chart.wid + 'px; padding: 0px; display: inline-block; position: relative; top: ' + chart.hei + 'px\">';\n        for (let i = 0; i < chart.data[0].datapoints.length; i++) {\n            pieChartDataDisplay += `<li style=\"width: 50%; float: left\">\n                    <span style=\"width:20px; height: 10px; display: inline-block; margin-right: 10px;\n                        background-color:${chart.data[0].datapoints[i].color};\n                        border: 1px solid black; border-radius: 2px;\"> </span>\n                    <span>${chart.data[0].datapoints[i].label} : ${chart.data[0].datapoints[i].y}</span>\n                </li>`;\n        }\n        pieChartDataDisplay += '</ul>';\n        chartContainerSelector.insertAdjacentHTML('beforeend', pieChartDataDisplay);\n        printAction(chartID, chart);\n        // console.log(\"End : pieChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in pie chart module:  \" + err.message);\n    }\n};\n\nconst GkDoughnutChart = data => {\n    try {\n        // console.log(\"Start : donutChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        let chartContainerSelector = document.querySelector(\"#\" + chart.container);\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.chartnumber = chartID;\n        chart.wid = chartContainerSelector.clientWidth;\n        chart.hei = chartContainerSelector.clientHeight - 33;\n\n        let chartHeight = chart.hei;\n\n        if (chart.hei > chart.wid) {\n            chartHeight = chart.wid;\n        }\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chartHeight, chart.container);\n        let canvas = 'canvas' + chart.chartnumber;\n        let linecord = [];\n        // let linewidth = 60;\n        for (let i = 0; i < chart.data.length; i++) {\n            drawDoughnutChart(canvas, ctx_base, chart.data[i], linecord, chartHeight);\n        }\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chartHeight, chart.container);\n        DoughnutChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container);\n\n        var pieChartDataDisplay = '<ul style=\"list-style: none; width: ' + chart.wid + 'px; padding: 0px; display: inline-block; position: relative; top: ' + chart.hei + 'px\">';\n        for (let i = 0; i < chart.data[0].datapoints.length; i++) {\n            pieChartDataDisplay += `<li style=\"width: 50%; float: left\">\n                    <span style=\"width:20px; height: 10px; display: inline-block; margin-right: 10px; \n                        background-color: ${chart.data[0].datapoints[i].color}; border: 1px solid black; border-radius: 2px;\"> </span>\n                    <span>${chart.data[0].datapoints[i].label} : ${chart.data[0].datapoints[i].y}</span>\n                </li>`;\n        }\n        pieChartDataDisplay += '</ul>';\n        chartContainerSelector.insertAdjacentHTML('beforeend', pieChartDataDisplay);\n        printAction(chartID, chart);\n        // console.log(\"End : donutChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in donut chart module:  \" + err.message);\n    }\n};\n\nconst GkMeterChart = data => {\n    try {\n        // console.log(\"Start : meterChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        let canvas = 'canvas' + chart.chartnumber;\n        let maxdata = [];\n        maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;\n        let meterTotal = 0;\n        for (let j = 0; j < chart.data[0].datapoints.length; j++) {\n            if (chart.data[0].datapoints[j].y < maxdata[0]) {\n                maxdata[0] = chart.data[0].datapoints[j].y;\n            }\n            if (chart.data[0].datapoints[j].y > maxdata[1]) {\n                maxdata[1] = chart.data[0].datapoints[j].y;\n            }\n            meterTotal += chart.data[0].datapoints[j].y;\n        }\n        // console.log(\"meterTotal \" + meterTotal);\n        let ChartDataToShow = chart.data[0].dataval;\n        // let linewidth = 50;\n        ChartDataToShow = Math.round(ChartDataToShow / meterTotal * 100);\n        //// console.log(ChartDataToShow);\n        drawMeterChart(canvas, ctx_base, 10, chart.data[0], maxdata, chart.data[0].chartColor, ChartDataToShow);\n        printAction(chartID, chart);\n        // console.log(\"End : meterChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in  meter chart module:  \" + err.message);\n    }\n};\n\nconst GkCombinationChart = data => {\n    try {\n        // console.log(\"Start : barChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        chart.yaxis === undefined ? chart.yaxis = {} : null;\n        if (!chart.yaxis.hasOwnProperty(\"max\") || !chart.yaxis.hasOwnProperty(\"min\")) {\n            let max = parseInt(chart.data[0].datapoints[0].y);\n            let min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < min) {\n                        min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > max) {\n                        max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            if (!chart.yaxis.hasOwnProperty(\"max\")) {\n                const extraAddition = max < 100 ? 2 : 10;\n                chart.yaxis.max = max + extraAddition;\n            }\n            if (!chart.yaxis.hasOwnProperty(\"min\")) {\n                chart.yaxis.min = chart.yaxis.min >= 10 ? min - 10 : min;\n            }\n            console.log(chart.yaxis.max, chart.yaxis.min);\n        }\n        if (!chart.yaxis.numOfRows) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        } else {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.numOfRows);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n        //// console.log(\"verticaldevisions\" + verticaldevisions);\n\n        let maxTextWidth = 30 + calcTextWidth(chart.data[0].datapoints, ctx_base, \"y\");\n        let canvas = 'canvas' + chart.chartnumber;\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data, maxTextWidth);\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart, maxTextWidth);\n\n        let range = [chart.yaxis.min, chart.yaxis.max];\n        //// console.log(\"maxdata:\" + maxdata);\n        // let linecord = [];\n        let columnCords = [];\n        let lineLineCords = [];\n        let nextcurve = 0;\n        let columnChartCount = 0;\n        for (let i in chart.data) {\n            chart.data[i] && chart.data[i].type === enums.columnChart ? columnChartCount++ : null;\n        }\n        const animate = false;\n        for (let j = 0; j < chart.data.length; j++) {\n            (i => {\n                if (chart.data[i] && chart.data[i].type === enums.columnChart) {\n                    const props = {\n                        canvas,\n                        ctx_base,\n                        verticaldevisions,\n                        data: chart.data[i],\n                        range,\n                        nextcurve,\n                        chartColor: chart.data[i].chartColor,\n                        columnCords,\n                        columnChartCount,\n                        animate,\n                        maxTextWidth\n                    };\n                    const rData = drawColumnChart(props);\n                    nextcurve += rData.barwidth + 5;\n                }\n                if (chart.data[i] && chart.data[i].type === enums.lineChart) {\n                    drawLineChart(canvas, ctx_base, verticaldevisions, chart.data[i], range, chart.data[i].chartColor, lineLineCords, maxTextWidth);\n                }\n                if (chart.data[i] && chart.data[i].type === enums.smoothLineChart) {\n                    drawSmoothLineChart(canvas, ctx_base, verticaldevisions, chart.data[i], range, chart.data[i].chartColor, lineLineCords, maxTextWidth);\n                }\n            })(j);\n        }\n        console.log(\"lineLineCords \", lineLineCords);\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        let finalCords = [...columnCords, ...lineLineCords];\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        columnChartUpperCanvas(chart.chartnumber, ctx_upper, finalCords, chart.container, chart, maxTextWidth);\n        LineChartUpperCanvas(chart.chartnumber, ctx_upper, finalCords, chart.container, chart, maxTextWidth);\n\n        printAction(chartID, chart);\n        // console.log(\"End : barChart\");\n    } catch (err) {\n        console.error(\"Exception occurred in bar chart module:  \" + err.message);\n    }\n};\n\nconst GkSparkChart = chartData => {\n    console.log(\"Will be coming soon\", chartData);\n};\n\nconst GkChart = chartData => {\n    try {\n        // console.info(\"Enter: Chart Designing initialize function\");\n        let chartType = chartData.data.config.chartType;\n\n        switch (chartType) {\n            case enums.lineChart:\n                {\n                    GkLineChart(chartData);\n                    break;\n                }\n\n            case enums.columnChart:\n                {\n                    GkColumnChart(chartData);\n                    break;\n                }\n\n            case enums.barChart:\n                {\n                    GkBarChart(chartData);\n                    break;\n                }\n\n            case enums.pieChart:\n                {\n                    GkPieChart(chartData);\n                    break;\n                }\n\n            case enums.doughnutChart:\n                {\n                    GkDoughnutChart(chartData);\n                    break;\n                }\n\n            case enums.meterChart:\n                {\n                    GkMeterChart(chartData);\n                    break;\n                }\n\n            case enums.combinationChart:\n                {\n                    GkCombinationChart(chartData);\n                    break;\n                }\n\n            case enums.smoothLineChart:\n                {\n                    GkSmoothLineChart(chartData);\n                    break;\n                }\n\n            case enums.stepLineChart:\n                {\n                    GkStepChart(chartData);\n                    break;\n                }\n\n            case enums.sparkChart:\n                {\n                    GkSparkChart(chartData);\n                    break;\n                }\n\n            case enums.stackedColumnChart:\n                {\n                    GkStackedChart(chartData);\n                    break;\n                }\n\n            case enums.stackedBarChart:\n                {\n                    GkStackedBarChart(chartData);\n                    break;\n                }\n\n            default:\n                {\n                    // console.log(\"Invalid choice of chart\");\n                    break;\n                }\n        }\n    } catch (err) {\n        console.log(\"Error Found in GKChart Constructor\", err);\n    }\n};\n\nexports.GkLineChart = GkLineChart;\nexports.GkStepChart = GkStepChart;\nexports.GkSmoothLineChart = GkSmoothLineChart;\nexports.GkBarChart = GkBarChart;\nexports.GkColumnChart = GkColumnChart;\nexports.GkPieChart = GkPieChart;\nexports.GkDoughnutChart = GkDoughnutChart;\nexports.GkMeterChart = GkMeterChart;\nexports.GkCombinationChart = GkCombinationChart;\nexports.GkChart = GkChart;\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./script.js":
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index__WEBPACK_IMPORTED_MODULE_0__);\n\nlet datapoints = [{ label: \"January\", y: 1 }, { label: \"February\", y: 2 }, { label: \"March\", y: 5 }, { label: \"April\", y: 7 }, { label: \"May\", y: 10 }, { label: \"June\", y: 12 }, { label: \"July\", y: 16 }, { label: \"August\", y: 12 }, { label: \"September\", y: 18 }, { label: \"October\", y: 15 }, { label: \"November\", y: 20 }, { label: \"December\", y: 22 }];\nlet datapoints1 = [{ label: \"January\", y: 18 }, { label: \"February\", y: 28 }, { label: \"March\", y: 34 }, { label: \"April\", y: 42 }, { label: \"May\", y: 54 }, { label: \"June\", y: 55 }, { label: \"July\", y: 70 }, { label: \"August\", y: 60 }, { label: \"September\", y: 72 }, { label: \"October\", y: 76 }, { label: \"November\", y: 87 }, { label: \"December\", y: 92 }];\nlet datapoints2 = [{ label: \"January\", y: 20 }, { label: \"February\", y: 22 }, { label: \"March\", y: 27 }, { label: \"April\", y: 22 }, { label: \"May\", y: 29 }, { label: \"June\", y: 20 }, { label: \"July\", y: 50 }, { label: \"August\", y: 40 }, { label: \"September\", y: 42 }, { label: \"October\", y: 46 }, { label: \"November\", y: 57 }, { label: \"December\", y: 52 }];\nlet datapoints3 = [{ label: \"January\", y: 16 }, { label: \"February\", y: 19 }, { label: \"March\", y: 21 }, { label: \"April\", y: 21 }, { label: \"May\", y: 24 }, { label: \"June\", y: 35 }, { label: \"July\", y: 40 }, { label: \"August\", y: 50 }, { label: \"September\", y: 60 }, { label: \"October\", y: 70 }, { label: \"November\", y: 80 }, { label: \"December\", y: 90 }];\n\nconst dataPoint5 = [{ label: \"East\", y: 1441290 }, { label: \"West\", y: 855912 }, { label: \"South\", y: 911404 }, { label: \"North\", y: 648136 }];\nconst dataPoint6 = [{ label: \"East\", y: 1297430 }, { label: \"West\", y: 776485 }, { label: \"South\", y: 685352 }, { label: \"North\", y: 726791 }];\nconst dataPoint7 = [{ label: \"East\", y: 143860 }, { label: \"West\", y: 79427 }, { label: \"South\", y: 226052 }, { label: \"North\", y: 78655 }];\n\n(function DrawChart() {\n    const lineChart = document.getElementById(\"line-chart\");\n    const chartLineFill = document.getElementById(\"chartLineFill\");\n    const lineChartComparision = document.getElementById(\"line-chart-comparision\");\n    const lineChartComparisionFill = document.getElementById(\"line-chart-comparision-fill\");\n\n    const barChart = document.getElementById(\"bar-chart\");\n    const barChartComparision = document.getElementById(\"bar-chart-comparision\");\n\n    const columnChart = document.getElementById(\"column-chart\");\n    const columnChartComparision = document.getElementById(\"column-chart-comparision\");\n\n    const columnChartWithSpline = document.getElementById(\"column-chart-with-smooth-line-chart\");\n    const columnLineAndAriaChart = document.getElementById(\"column-line-and-aria-chart\");\n    const columnSmoothLineAndAriaChart = document.getElementById(\"column-smooth-line-and-aria-chart\");\n\n    const stackedChart = document.getElementById(\"stacked-column-chart\");\n    const groupStackedChart = document.getElementById(\"group-stacked-column-chart\");\n\n    const stackedBarChart = document.getElementById(\"stacked-bar-chart\");\n    const groupStackedBarChart = document.getElementById(\"group-stacked-bar-chart\");\n\n    const doughnutChart = document.getElementById(\"doughnut-chart\");\n    const meterChart = document.getElementById(\"meter-chart\");\n    const pieChartId = document.getElementById(\"pie-chart\");\n\n    const smoothChartId = document.getElementById(\"smooth-chart\");\n    const smoothChartComparisionId = document.getElementById(\"smooth-chart-comparision\");\n    const smoothChartFillId = document.getElementById(\"smooth-chart-fill\");\n    const smoothChartComparisionFillId = document.getElementById(\"smooth-chart-comparision-fill\");\n\n    const stepChartId = document.getElementById(\"step-chart\");\n    const stepChartComparisionId = document.getElementById(\"step-chart-comparision\");\n    const stepChartFillId = document.getElementById(\"step-chart-fill\");\n    const stepChartComparisionFillId = document.getElementById(\"step-chart-comparision-fill\");\n\n    if (lineChart) {\n\n        let chartline = {\n            config: {\n                title: \"Line Chart\",\n                chartType: \"line-chart\",\n                printEnable: true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            data: [{\n                chartColor: \"#5d62b5\",\n                fill: false,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"line-chart\",\n            data: chartline\n        });\n    }\n\n    if (chartLineFill) {\n\n        let chartLineFill = {\n            config: {\n                title: \"Line Chart Fill\",\n                chartType: \"line-chart\",\n                printEnable: true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            data: [{\n                chartColor: \"#5d62b5\",\n                fill: true,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"chartLineFill\",\n            data: chartLineFill\n        });\n    }\n\n    if (lineChartComparision) {\n\n        var chartlineComparision = {\n            config: {\n                title: \"Multi Line Comparision Chart\",\n                chartType: \"line-chart\",\n                printEnable: true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            data: [{\n                chartColor: \"#5d62b5\",\n                fill: false,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: false,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: false,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: false,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"line-chart-comparision\",\n            data: chartlineComparision\n        });\n    }\n\n    if (lineChartComparisionFill) {\n        var chartlineComparisionFill = {\n            config: {\n                title: \"Multi Line Comparision Chart\",\n                chartType: \"line-chart\",\n                printEnable: true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            data: [{\n                chartColor: \"#5d62b5\",\n                fill: true,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: true,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: true,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: true,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"line-chart-comparision-fill\",\n            data: chartlineComparisionFill\n        });\n    }\n\n    if (columnChart) {\n        let chartbar = {\n            \"config\": {\n                \"title\": \"Column Chart\",\n                \"chartType\": 'column-chart',\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"column-chart\", data: chartbar });\n    }\n\n    if (columnChartComparision) {\n        const chartmultibar = {\n            \"config\": {\n                \"title\": \"Multi Column Chart Comparision\",\n                \"chartType\": 'column-chart',\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                chartColor: \"teal\",\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints3\n            }, {\n                chartColor: \"green\",\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"yellow\",\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"column-chart-comparision\", data: chartmultibar });\n    }\n\n    if (barChart) {\n        let chartbar = {\n            \"config\": {\n                \"title\": \"Bar Chart\",\n                \"chartType\": 'bar-chart',\n                \"printEnable\": true\n            },\n            xAxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"Travel & Leisure\" }, { label: \"Advertising/Marketing/PR\" }, { label: \"Other\" }, { label: \"Real Estate\" }, { label: \"Communications/Cable/Phone\" }, { label: \"Construction\" }, { label: \"Entertainment\" }, { label: \"Staffing Firm/Full Time/Temporary\" }, { label: \"Transportation/Logistics\" }, { label: \"Utilities\" }, { label: \"Aerospace/Defense Products\" }, { label: \"Banking/Finance/Securities\" }, { label: \"Consumer Products - Non-Durables\" }, { label: \"Distribution\" }],\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": [{ value: \"41\" }, { value: \"39\" }, { value: \"38\" }, { value: \"32\" }, { value: \"26\" }, { value: \"25\" }, { value: \"25\" }, { value: \"24\" }, { value: \"23\" }, { value: \"22\" }, { value: \"18\" }, { value: \"16\" }, { value: \"15\" }, { value: \"13\" }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"bar-chart\", data: chartbar });\n    }\n\n    if (barChartComparision) {\n        const chartmultibar = {\n            \"config\": {\n                \"title\": \"Bar Chart\",\n                \"chartType\": 'bar-chart',\n                \"printEnable\": true\n            },\n            xaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"Travel & Leisure\" }, { label: \"Advertising/Marketing/PR\" }, { label: \"Other\" }, { label: \"Real Estate\" }, { label: \"Communications/Cable/Phone\" }, { label: \"Construction\" }, { label: \"Entertainment\" }, { label: \"Staffing Firm/Full Time/Temporary\" }, { label: \"Transportation/Logistics\" }, { label: \"Utilities\" }, { label: \"Aerospace/Defense Products\" }, { label: \"Banking/Finance/Securities\" }, { label: \"Consumer Products - Non-Durables\" }, { label: \"Distribution\" }],\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": [{ value: \"41\" }, { value: \"39\" }, { value: \"38\" }, { value: \"32\" }, { value: \"26\" }, { value: \"25\" }, { value: \"25\" }, { value: \"24\" }, { value: \"23\" }, { value: \"22\" }, { value: \"18\" }, { value: \"16\" }]\n            }, {\n                \"chartColor\": \"#29c3be\",\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": [{ value: \"30\" }, { value: \"20\" }, { value: \"18\" }, { value: \"41\" }, { value: \"40\" }, { value: \"35\" }, { value: \"15\" }, { value: \"4\" }, { value: \"2\" }, { value: \"28\" }, { value: \"38\" }, { value: \"36\" }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"bar-chart-comparision\", data: chartmultibar });\n    }\n\n    if (columnChartWithSpline) {\n\n        var chartbar = {\n            \"config\": {\n                \"title\": \"Bar Chart and Smooth Line Comparision\",\n                \"chartType\": 'combination-chart',\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": datapoints2\n            }, {\n                \"chartColor\": \"teal\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 2\",\n                \"datapoints\": datapoints3\n            }, {\n                \"chartColor\": \"#ffc533\",\n                \"type\": 'line-chart',\n                \"dataLabel\": \"Data set 3\",\n                \"datapoints\": datapoints\n            }, {\n                \"chartColor\": \"#29c3be\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 6\",\n                \"datapoints\": datapoints\n            }, {\n                \"chartColor\": \"#ff00dd\",\n                \"type\": 'smooth-line-chart',\n                \"dataLabel\": \"Data set 4\",\n                \"datapoints\": datapoints1\n            }, {\n                \"chartColor\": \"#f2726f\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 5\",\n                \"datapoints\": datapoints1\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"column-chart-with-smooth-line-chart\", data: chartbar });\n    }\n\n    if (doughnutChart) {\n        const doughnut = {\n            \"config\": {\n                \"title\": \"Doughnut Chart\",\n                \"chartType\": \"doughnut-chart\",\n                \"printEnable\": true\n            },\n            \"data\": [{\n                \"chartColor\": \"#29c3be\",\n                \"datapoints\": [{\n                    \"label\": \"Jan\",\n                    \"y\": 200,\n                    \"color\": \"teal\"\n                }, {\n                    \"label\": \"Feb\",\n                    \"y\": 90,\n                    \"color\": \"#b84335\"\n                }, {\n                    \"label\": \"Mar\",\n                    \"y\": 45,\n                    \"color\": \"#fbbc05\"\n                }, {\n                    \"label\": \"Apr\",\n                    \"y\": 70,\n                    \"color\": \"gray\"\n                }, {\n                    \"label\": \"May\",\n                    \"y\": 95,\n                    \"color\": \"purple\"\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"doughnut-chart\", data: doughnut });\n    }\n\n    if (meterChart) {\n        const meter = {\n            \"config\": {\n                \"title\": \"Meter Gauge Chart\",\n                \"chartType\": \"meter-chart\",\n                \"printEnable\": true\n            },\n            \"data\": [/*Give as required data in given formate, syntax error with json will cause of error in charts*/{\n                \"chartColor\": \"#29c3be\",\n                \"datapoints\": [{\n                    \"label\": \"Poor\",\n                    \"y\": 50,\n                    \"color\": \"#29c3be\"\n                }, {\n                    \"label\": \"Blw Avg\",\n                    \"y\": 25,\n                    \"color\": \"#29c3be\"\n                }, {\n                    \"label\": \"Average\",\n                    \"y\": 25,\n                    \"color\": \"#00ff00\"\n                }, {\n                    \"label\": \"Abv Avg\",\n                    \"y\": 35,\n                    \"color\": \"#00ff00\"\n                }, {\n                    \"label\": \"Exceed\",\n                    \"y\": 10,\n                    \"color\": \"#00ff00\"\n                }],\n                dataval: 77\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"meter-chart\", data: meter });\n    }\n\n    if (pieChartId) {\n        const pieChart = {\n            \"config\": {\n                \"title\": \"Pie Chart\",\n                \"chartType\": \"pie-chart\",\n                \"printEnable\": true\n            },\n            \"data\": [{\n                \"datapoints\": [{\n                    \"label\": \"Jan\",\n                    \"y\": 200,\n                    \"color\": \"teal\"\n                }, {\n                    \"label\": \"Feb\",\n                    \"y\": 90,\n                    \"color\": \"#b84335\"\n                }, {\n                    \"label\": \"Mar\",\n                    \"y\": 45,\n                    \"color\": \"#fbbc05\"\n                }, {\n                    \"label\": \"Apr\",\n                    \"y\": 70,\n                    \"color\": \"gray\"\n                }, {\n                    \"label\": \"May\",\n                    \"y\": 95,\n                    \"color\": \"purple\"\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"pie-chart\", data: pieChart });\n    }\n\n    if (smoothChartId) {\n\n        const chartsmoothline = {\n            \"config\": {\n                \"title\": \"Smooth Line Chart\",\n                \"chartType\": \"smooth-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"fill\": false,\n                \"dataLabel\": \"Data Set 1\",\n                \"datapoints\": datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"smooth-chart\", data: chartsmoothline });\n    }\n\n    if (smoothChartComparisionId) {\n\n        const smoothLineComparision = {\n            \"config\": {\n                \"title\": \"Multi Smooth Line Comparision Chart\",\n                \"chartType\": \"smooth-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                chartColor: \"#5d62b5\",\n                fill: false,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: false,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: false,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: false,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"smooth-chart-comparision\", data: smoothLineComparision });\n    }\n\n    if (smoothChartFillId) {\n\n        const chartsmoothlinefill = {\n            \"config\": {\n                \"title\": \"Smooth Line Chart\",\n                \"chartType\": \"smooth-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"fill\": true,\n                \"dataLabel\": \"Data Set 1\",\n                \"datapoints\": datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"smooth-chart-fill\", data: chartsmoothlinefill });\n    }\n\n    if (smoothChartComparisionFillId) {\n\n        const smoothLineComparisionFill = {\n            \"config\": {\n                \"title\": \"Multi Smooth Line Comparision Chart\",\n                \"chartType\": \"smooth-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                chartColor: \"#5d62b5\",\n                fill: true,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: true,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: true,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: true,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"smooth-chart-comparision-fill\", data: smoothLineComparisionFill });\n    }\n\n    if (stepChartId) {\n\n        const stepChart = {\n            \"config\": {\n                \"title\": \"Step Chart\",\n                \"chartType\": \"step-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"fill\": false,\n                \"dataLabel\": \"Data Set 1\",\n                \"datapoints\": datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"step-chart\",\n            data: stepChart\n        });\n    }\n\n    if (stepChartComparisionId) {\n\n        let stepChartComparision = {\n            \"config\": {\n                \"title\": \"Multi Step Comparision Chart\",\n                \"chartType\": \"step-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                chartColor: \"#5d62b5\",\n                fill: false,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: false,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: false,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: false,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"step-chart-comparision\",\n            data: stepChartComparision\n        });\n    }\n\n    if (stepChartFillId) {\n\n        const stepChartFill = {\n            \"config\": {\n                \"title\": \"Step Chart\",\n                \"chartType\": \"step-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"fill\": true,\n                \"dataLabel\": \"Data Set 1\",\n                \"datapoints\": datapoints\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"step-chart-fill\",\n            data: stepChartFill\n        });\n    }\n\n    if (stepChartComparisionFillId) {\n\n        let stepChartComparisionFill = {\n            \"config\": {\n                \"title\": \"Multi Step Comparision Chart\",\n                \"chartType\": \"step-line-chart\",\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                chartColor: \"#5d62b5\",\n                fill: true,\n                dataLabel: \"Data Set 1\",\n                datapoints: datapoints\n            }, {\n                chartColor: \"#29c3be\",\n                fill: true,\n                dataLabel: \"Data Set 2\",\n                datapoints: datapoints1\n            }, {\n                chartColor: \"#ff00dd\",\n                fill: true,\n                dataLabel: \"Data Set 3\",\n                datapoints: datapoints2\n            }, {\n                chartColor: \"#f2726f\",\n                fill: true,\n                dataLabel: \"Data Set 4\",\n                datapoints: datapoints3\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({\n            id: \"step-chart-comparision-fill\",\n            data: stepChartComparisionFill\n        });\n    }\n\n    if (columnLineAndAriaChart) {\n        const chartbar = {\n            \"config\": {\n                \"title\": \"Column line and aria chart\",\n                \"chartType\": 'combination-chart',\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Miles\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": dataPoint5\n            }, {\n                \"chartColor\": \"#29c3be\",\n                \"type\": 'line-chart',\n                \"dataLabel\": \"Data set 6\",\n                \"datapoints\": dataPoint6\n            }, {\n                \"chartColor\": \"#f2726f\",\n                \"type\": 'line-chart',\n                \"fill\": true,\n                \"dataLabel\": \"Data set 5\",\n                \"datapoints\": dataPoint7\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"column-line-and-aria-chart\", data: chartbar });\n    }\n\n    if (columnSmoothLineAndAriaChart) {\n        const chartbar = {\n            \"config\": {\n                \"title\": \"Column line and aria chart\",\n                \"chartType\": 'combination-chart',\n                \"printEnable\": true\n            },\n            yaxis: {\n                min: 0,\n                numOfRows: 5,\n                title: \"Hours\"\n            },\n            \"data\": [{\n                \"chartColor\": \"#5d62b5\",\n                \"type\": 'column-chart',\n                \"dataLabel\": \"Data set 1\",\n                \"datapoints\": dataPoint5\n            }, {\n                \"chartColor\": \"#29c3be\",\n                \"type\": 'smooth-line-chart',\n                \"dataLabel\": \"Data set 6\",\n                \"datapoints\": dataPoint6\n            }, {\n                \"chartColor\": \"#f2726f\",\n                \"type\": 'smooth-line-chart',\n                \"fill\": true,\n                \"dataLabel\": \"Data set 5\",\n                \"datapoints\": dataPoint7\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"column-smooth-line-and-aria-chart\", data: chartbar });\n    }\n\n    if (stackedChart) {\n\n        const chartData = {\n            config: {\n                title: \"Stacked Column Chart\",\n                chartType: \"stacked-column-chart\",\n                printEnable: true\n            },\n            yAxis: {\n                min: 0,\n                rowCount: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"January\" }, { label: \"February\" }, { label: \"March\" }, { label: \"April\" }, { label: \"May\" }, { label: \"June\" }, { label: \"July\" }, { label: \"August\" }, { label: \"September\" }],\n            data: [{\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 5 }, { value: 10 }, { value: 8 }, { value: 6 }, { value: 2 }, { value: 9 }, { value: 19 }, { value: 5 }, { value: 2 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 2 }, { value: 6 }, { value: 12 }, { value: 15 }, { value: 1 }, { value: 5 }, { value: 15 }, { value: 25 }, { value: 5 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 8 }, { value: 4 }, { value: 5 }, { value: 5 }, { value: 10 }, { value: 15 }, { value: 1 }, { value: 10 }, { value: 25 }]\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"stacked-column-chart\", data: chartData });\n    }\n\n    if (groupStackedChart) {\n\n        const chartData = {\n            config: {\n                title: \"Group Stacked Column Chart\",\n                chartType: \"stacked-column-chart\",\n                printEnable: true\n            },\n            yAxis: {\n                min: 0,\n                rowCount: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"January\" }, { label: \"February\" }, { label: \"March\" }, { label: \"April\" }, { label: \"May\" }, { label: \"June\" }, { label: \"July\" }, { label: \"August\" }, { label: \"September\" }],\n            data: [{\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 5 }, { value: 10 }, { value: 8 }, { value: 6 }, { value: 2 }, { value: 9 }, { value: 19 }, { value: 5 }, { value: 2 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 2 }, { value: 6 }, { value: 12 }, { value: 15 }, { value: 1 }, { value: 5 }, { value: 15 }, { value: 25 }, { value: 5 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 8 }, { value: 4 }, { value: 5 }, { value: 5 }, { value: 10 }, { value: 15 }, { value: 1 }, { value: 10 }, { value: 25 }]\n                }]\n            }, {\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 15 }, { value: 1 }, { value: 18 }, { value: 10 }, { value: 12 }, { value: 19 }, { value: 9 }, { value: 15 }, { value: 22 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 12 }, { value: 16 }, { value: 2 }, { value: 5 }, { value: 11 }, { value: 25 }, { value: 5 }, { value: 21 }, { value: 35 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 18 }, { value: 24 }, { value: 15 }, { value: 35 }, { value: 1 }, { value: 1 }, { value: 11 }, { value: 16 }, { value: 2 }]\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"group-stacked-column-chart\", data: chartData });\n    }\n\n    if (stackedBarChart) {\n\n        const chartData = {\n            config: {\n                title: \"Stacked Bar Chart\",\n                chartType: \"stacked-bar-chart\",\n                printEnable: true\n            },\n            xAxis: {\n                min: 0,\n                rowCount: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"January\" }, { label: \"February\" }, { label: \"March\" }, { label: \"April\" }, { label: \"May\" }, { label: \"June\" }, { label: \"July\" }, { label: \"August\" }, { label: \"September\" }],\n            data: [{\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 5 }, { value: 10 }, { value: 8 }, { value: 6 }, { value: 2 }, { value: 9 }, { value: 19 }, { value: 5 }, { value: 2 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 2 }, { value: 6 }, { value: 12 }, { value: 15 }, { value: 1 }, { value: 5 }, { value: 15 }, { value: 25 }, { value: 5 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 8 }, { value: 4 }, { value: 5 }, { value: 5 }, { value: 10 }, { value: 15 }, { value: 1 }, { value: 10 }, { value: 25 }]\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"stacked-bar-chart\", data: chartData });\n    }\n\n    if (groupStackedBarChart) {\n\n        const chartData = {\n            config: {\n                title: \"Stacked Chart\",\n                chartType: \"stacked-bar-chart\",\n                printEnable: true\n            },\n            xAxis: {\n                min: 0,\n                rowCount: 5,\n                title: \"Hours\"\n            },\n            categories: [{ label: \"January\" }, { label: \"February\" }, { label: \"March\" }, { label: \"April\" }, { label: \"May\" }, { label: \"June\" }, { label: \"July\" }, { label: \"August\" }, { label: \"September\" }],\n            data: [{\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 5 }, { value: 10 }, { value: 8 }, { value: 6 }, { value: 2 }, { value: 9 }, { value: 19 }, { value: 5 }, { value: 2 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 2 }, { value: 6 }, { value: 12 }, { value: 15 }, { value: 1 }, { value: 5 }, { value: 15 }, { value: 25 }, { value: 5 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 8 }, { value: 4 }, { value: 5 }, { value: 5 }, { value: 10 }, { value: 15 }, { value: 1 }, { value: 10 }, { value: 25 }]\n                }]\n            }, {\n                dataSet: [{\n                    color: \"#5d62b5\",\n                    dataLabel: \"Oil\",\n                    dataPoints: [{ value: 15 }, { value: 1 }, { value: 18 }, { value: 10 }, { value: 12 }, { value: 19 }, { value: 9 }, { value: 15 }, { value: 22 }]\n                }, {\n                    color: \"#29c3be\",\n                    dataLabel: \"Gas\",\n                    dataPoints: [{ value: 12 }, { value: 16 }, { value: 2 }, { value: 5 }, { value: 11 }, { value: 25 }, { value: 5 }, { value: 21 }, { value: 35 }]\n                }, {\n                    color: \"#f2726f\",\n                    dataLabel: \"Petrol\",\n                    dataPoints: [{ value: 18 }, { value: 24 }, { value: 15 }, { value: 35 }, { value: 1 }, { value: 1 }, { value: 11 }, { value: 16 }, { value: 2 }]\n                }]\n            }]\n        };\n\n        Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"GkChart\"])({ id: \"group-stacked-bar-chart\", data: chartData });\n    }\n})();\n\n//# sourceURL=webpack:///./script.js?");

/***/ }),

/***/ "./src/common/calc-text-width.js":
/*!***************************************!*\
  !*** ./src/common/calc-text-width.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const calcTextWidth = (data, ctx, calcFor) => {\n    return data.reduce((acc, value) => {\n        const labelTextWidth = ctx.measureText(value[calcFor]).width;\n        if (labelTextWidth > acc) {\n            acc = labelTextWidth + 20;\n        }\n        return acc;\n    }, 0);\n};\n\nmodule.exports = calcTextWidth;\n\n//# sourceURL=webpack:///./src/common/calc-text-width.js?");

/***/ }),

/***/ "./src/common/canvas_to_image.js":
/*!***************************************!*\
  !*** ./src/common/canvas_to_image.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * covert canvas to image\n * and save the image file\n */\n\nvar Canvas2Image = function () {\n\n    // check if support sth.\n    var $support = function () {\n        var canvas = document.createElement('canvas'),\n            ctx = canvas.getContext('2d');\n\n        return {\n            canvas: !!ctx,\n            imageData: !!ctx.getImageData,\n            dataURL: !!canvas.toDataURL,\n            btoa: !!window.btoa\n        };\n    }();\n\n    var downloadMime = 'image/octet-stream';\n\n    function scaleCanvas(canvas, width, height) {\n        var w = canvas.width,\n            h = canvas.height;\n        if (width == undefined) {\n            width = w;\n        }\n        if (height == undefined) {\n            height = h;\n        }\n\n        var retCanvas = document.createElement('canvas');\n        var retCtx = retCanvas.getContext('2d');\n        retCanvas.width = width;\n        retCanvas.height = height;\n        retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);\n        return retCanvas;\n    }\n\n    function getDataURL(canvas, type, width, height) {\n        canvas = scaleCanvas(canvas, width, height);\n        return canvas.toDataURL(type);\n    }\n\n    function saveFile(strData) {\n        document.location.href = strData;\n    }\n\n    function genImage(strData) {\n        var img = document.createElement('img');\n        img.src = strData;\n        return img;\n    }\n\n    function fixType(type) {\n        type = type.toLowerCase().replace(/jpg/i, 'jpeg');\n        var r = type.match(/png|jpeg|bmp|gif/)[0];\n        return 'image/' + r;\n    }\n\n    function encodeData(data) {\n        if (!window.btoa) {\n            throw 'btoa undefined';\n        }\n        var str = '';\n        if (typeof data == 'string') {\n            str = data;\n        } else {\n            for (var i = 0; i < data.length; i++) {\n                str += String.fromCharCode(data[i]);\n            }\n        }\n\n        return btoa(str);\n    }\n\n    function getImageData(canvas) {\n        var w = canvas.width,\n            h = canvas.height;\n        return canvas.getContext('2d').getImageData(0, 0, w, h);\n    }\n\n    function makeURI(strData, type) {\n        return 'data:' + type + ';base64,' + strData;\n    }\n\n    /**\n     * create bitmap image\n     */\n    var genBitmapImage = function (oData) {\n\n        var biWidth = oData.width;\n        var biHeight = oData.height;\n        var biSizeImage = biWidth * biHeight * 3;\n        var bfSize = biSizeImage + 54; // total header size = 54 bytes\n\n        //\n        //  typedef struct tagBITMAPFILEHEADER {\n        //  \tWORD bfType;\n        //  \tDWORD bfSize;\n        //  \tWORD bfReserved1;\n        //  \tWORD bfReserved2;\n        //  \tDWORD bfOffBits;\n        //  } BITMAPFILEHEADER;\n        //\n        var BITMAPFILEHEADER = [\n        // WORD bfType -- The file type signature; must be \"BM\"\n        0x42, 0x4D,\n        // DWORD bfSize -- The size, in bytes, of the bitmap file\n        bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,\n        // WORD bfReserved1 -- Reserved; must be zero\n        0, 0,\n        // WORD bfReserved2 -- Reserved; must be zero\n        0, 0,\n        // DWORD bfOffBits -- The offset, in bytes, from the beginning of the BITMAPFILEHEADER structure to the bitmap bits.\n        54, 0, 0, 0];\n\n        //\n        //  typedef struct tagBITMAPINFOHEADER {\n        //  \tDWORD biSize;\n        //  \tLONG  biWidth;\n        //  \tLONG  biHeight;\n        //  \tWORD  biPlanes;\n        //  \tWORD  biBitCount;\n        //  \tDWORD biCompression;\n        //  \tDWORD biSizeImage;\n        //  \tLONG  biXPelsPerMeter;\n        //  \tLONG  biYPelsPerMeter;\n        //  \tDWORD biClrUsed;\n        //  \tDWORD biClrImportant;\n        //  } BITMAPINFOHEADER, *PBITMAPINFOHEADER;\n        //\n        var BITMAPINFOHEADER = [\n        // DWORD biSize -- The number of bytes required by the structure\n        40, 0, 0, 0,\n        // LONG biWidth -- The width of the bitmap, in pixels\n        biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,\n        // LONG biHeight -- The height of the bitmap, in pixels\n        biHeight & 0xff, biHeight >> 8 & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,\n        // WORD biPlanes -- The number of planes for the target device. This value must be set to 1\n        1, 0,\n        // WORD biBitCount -- The number of bits-per-pixel, 24 bits-per-pixel -- the bitmap\n        // has a maximum of 2^24 colors (16777216, Truecolor)\n        24, 0,\n        // DWORD biCompression -- The type of compression, BI_RGB (code 0) -- uncompressed\n        0, 0, 0, 0,\n        // DWORD biSizeImage -- The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps\n        biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,\n        // LONG biXPelsPerMeter, unused\n        0, 0, 0, 0,\n        // LONG biYPelsPerMeter, unused\n        0, 0, 0, 0,\n        // DWORD biClrUsed, the number of color indexes of palette, unused\n        0, 0, 0, 0,\n        // DWORD biClrImportant, unused\n        0, 0, 0, 0];\n\n        var iPadding = (4 - biWidth * 3 % 4) % 4;\n\n        var aImgData = oData.data;\n\n        var strPixelData = '';\n        var biWidth4 = biWidth << 2;\n        var y = biHeight;\n        var fromCharCode = String.fromCharCode;\n\n        do {\n            var iOffsetY = biWidth4 * (y - 1);\n            var strPixelRow = '';\n            for (var x = 0; x < biWidth; x++) {\n                var iOffsetX = x << 2;\n                strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) + fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) + fromCharCode(aImgData[iOffsetY + iOffsetX]);\n            }\n\n            for (var c = 0; c < iPadding; c++) {\n                strPixelRow += String.fromCharCode(0);\n            }\n\n            strPixelData += strPixelRow;\n        } while (--y);\n\n        var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);\n\n        return strEncoded;\n    };\n\n    /**\n     * saveAsImage\n     * @param canvasElement\n     * @param {String} image type\n     * @param {Number} [optional] png width\n     * @param {Number} [optional] png height\n     */\n    var saveAsImage = function (canvas, width, height, type) {\n        if ($support.canvas && $support.dataURL) {\n            if (typeof canvas == \"string\") {\n                canvas = document.getElementById(canvas);\n            }\n            if (type == undefined) {\n                type = 'png';\n            }\n            type = fixType(type);\n            if (/bmp/.test(type)) {\n                var data = getImageData(scaleCanvas(canvas, width, height));\n                var strData = genBitmapImage(data);\n                saveFile(makeURI(strData, downloadMime));\n            } else {\n                var strData = getDataURL(canvas, type, width, height);\n                saveFile(strData.replace(type, downloadMime));\n            }\n        }\n    };\n\n    var convertToImage = function (canvas, width, height, type) {\n        if ($support.canvas && $support.dataURL) {\n            if (typeof canvas == \"string\") {\n                canvas = document.getElementById(canvas);\n            }\n            if (type == undefined) {\n                type = 'png';\n            }\n            type = fixType(type);\n\n            if (/bmp/.test(type)) {\n                var data = getImageData(scaleCanvas(canvas, width, height));\n                var strData = genBitmapImage(data);\n                return genImage(makeURI(strData, 'image/bmp'));\n            } else {\n                var strData = getDataURL(canvas, type, width, height);\n                return genImage(strData);\n            }\n        }\n    };\n\n    return {\n        saveAsImage: saveAsImage,\n        saveAsPNG: function (canvas, width, height) {\n            return saveAsImage(canvas, width, height, 'png');\n        },\n        saveAsJPEG: function (canvas, width, height) {\n            return saveAsImage(canvas, width, height, 'jpeg');\n        }\n        // saveAsGIF: function (canvas, width, height) {\n        //   return saveAsImage(canvas, width, height, 'gif');\n        // },\n        // saveAsBMP: function (canvas, width, height) {\n        //   return saveAsImage(canvas, width, height, 'bmp');\n        // },\n\n        // convertToImage: convertToImage,\n        // convertToPNG: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'png');\n        // },\n        // convertToJPEG: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'jpeg');\n        // },\n        // convertToGIF: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'gif');\n        // },\n        // convertToBMP: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'bmp');\n        // }\n    };\n};\n\nmodule.exports = Canvas2Image;\n\n//# sourceURL=webpack:///./src/common/canvas_to_image.js?");

/***/ }),

/***/ "./src/common/chart_surface.js":
/*!*************************************!*\
  !*** ./src/common/chart_surface.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartEnums = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\nconst font = gkChartEnums.font;\nconst toolTipBgColor = gkChartEnums.toolTipBgColor;\n\nclass ChartSurface {\n\n    ratio(canvasContainer) {\n        // let ctx = canvasContainer.getContext('2d');\n        // let dpr = window.devicePixelRatio || 1;\n        // let bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n        // return dpr / bsr;\n        return 2;\n    }\n\n    prepSurface(nr, width, height, containerId) {\n        try {\n            // console.log(\"Start : prepSurface\");\n            const canvas = document.createElement(\"CANVAS\");\n            canvas.id = 'canvas' + nr;\n            canvas.setAttribute('class', 'canvas');\n            canvas.setAttribute(\"style\", \"position:absolute\");\n            const container = document.getElementById(containerId);\n            container.appendChild(canvas);\n\n            const canvasDom = document.getElementById('canvas' + nr);\n            canvasDom.width = width * this.ratio(canvasDom);\n            canvasDom.height = height * this.ratio(canvasDom);\n            canvasDom.style.width = width + \"px\";\n            canvasDom.style.height = height + \"px\";\n\n            // document.getElementById('container').append('<canvas id=\"canvas' + nr + '\" class=\"canvas\"' +\n            //     ' style=\"position:absolute;\" width=\"' + width + '\" height=\"' + height + '\"></canvas> ');\n            // console.log(\"End : prepSurface\");\n        } catch (e) {\n            console.log(\"error occurred in prepareSurface : \", e);\n        }\n    }\n\n    prepUI(nr) {\n        try {\n            // console.log(\"Start : prepUI\");\n            //// console.log(nr);\n            const canvas = document.getElementById('canvas' + nr);\n            const ctx = canvas.getContext('2d');\n            ctx.font = font;\n            ctx.lineWidth = 1;\n            // console.log(\"End : prepUI\");\n            return ctx;\n        } catch (e) {\n            console.log(\"error occurred in prepUI : \", e);\n        }\n    }\n\n    preparePlot(nr, sizex, sizey, container) {\n        try {\n            // console.log(\"Start : preparePlot\");\n            this.prepSurface(nr, sizex, sizey, container);\n            const canvasContext = this.prepUI(nr);\n            // console.log(\"End : preparePlot\");\n            return canvasContext;\n        } catch (e) {\n            console.log(\"error occurred in preparePlot : \", e);\n        }\n    }\n\n    prepSurfaceupper(nr, width, height, containerId) {\n        try {\n            // console.log(\"Start : prepSurfaceupper\");\n            const container = document.getElementById(containerId);\n            let innerCotent = `<canvas id=\"canvasupper${nr}\" class=\"canvas\" style=\"position:absolute;\"\n                    width=\"${width}\" height=\"${height}\"> </canvas>\n                <div class=\"canvasjs-chart-tooltip\" style=\"position:absolute;height:auto;\n                    box-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 2px 2px; z-index: 1000; display: none; \n                    border-radius: 3px; transition: left 0.2s ease-out, bottom 0.2s ease-out; pointer-events: none;\n                    background-color: ${toolTipBgColor}; border: 1px solid rgba(0,0,0,.5); padding: 5px;color: #fff\">\n                        <span style=\"color:#7F6084;\"> </span>\n                </div>`;\n            container.insertAdjacentHTML('beforeend', innerCotent);\n\n            let canvasDom = document.getElementById('canvasupper' + nr);\n            canvasDom.width = width * this.ratio(canvasDom);\n            canvasDom.height = height * this.ratio(canvasDom);\n            canvasDom.style.width = width + \"px\";\n            canvasDom.style.height = height + \"px\";\n\n            // console.log(\"End : prepSurfaceupper\");\n        } catch (e) {\n            console.log(\"error occurred in prepSurfaceupper : \", e);\n        }\n    }\n\n    prepUIUpper(nr) {\n        try {\n            // console.log(\"Start : prepUIUpper\");\n            const canvas = document.getElementById('canvasupper' + nr);\n            const ctx = canvas.getContext('2d');\n            //ctx.font = '18px Arial';\n            ctx.lineWidth = 1;\n            // console.log(\"End : prepUIUpper\");\n            return ctx;\n        } catch (e) {\n            console.log(\"error occurred in prepUIUpper : \", e);\n        }\n    }\n\n    preparePlotUpper(nr, sizex, sizey, container) {\n        try {\n            // console.log(\"Start : preparePlotUpper\");\n            this.prepSurfaceupper(nr, sizex, sizey, container);\n            const canvasContext = this.prepUIUpper(nr);\n            // console.log(\"End : preparePlotUpper\");\n            return canvasContext;\n        } catch (e) {\n            console.log(\"error occurred in preparePlotUpper : \", e);\n        }\n    }\n}\n\nmodule.exports = ChartSurface;\n\n//# sourceURL=webpack:///./src/common/chart_surface.js?");

/***/ }),

/***/ "./src/common/css_style.js":
/*!*********************************!*\
  !*** ./src/common/css_style.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function cssStyle(el, styles) {\n    for (var property in styles) {\n        el.style[property] = styles[property];\n    }\n}\n\nmodule.exports = cssStyle;\n\n//# sourceURL=webpack:///./src/common/css_style.js?");

/***/ }),

/***/ "./src/common/drawChart/bar_chart_canvas.js":
/*!**************************************************!*\
  !*** ./src/common/drawChart/bar_chart_canvas.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawBarChart(props) {\n    try {\n        // console.log(\"Start : drawBar\");\n        const canvasId = props.canvas;\n        const ctx = props.ctx_base;\n        const horizontalNr = props.horizontalNr;\n        const data = props.data;\n        const range = props.rangedata;\n        const curx = props.nextcurve;\n        const chartColor = props.chartColor;\n        const linecord = props.linecord;\n        const barChartCount = props.barChartCount;\n        const chartDataLength = props.chartDataLength;\n        const maxTextWidth = props.maxTextWidth;\n        const categories = props.categories;\n\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n\n        const spacingVertical = hei / data.datapoints.length;\n        const totalRange = range[1] - range[0];\n        // const verticalCoefficient = hei / totalRange;\n        const horizontalCoefficient = wid / totalRange;\n        const barHeight = spacingVertical / chartDataLength * .80;\n\n        const calcWayPoints = points => {\n            let wayPoints = [];\n            for (let i = 0; i < points.length; i++) {\n                const x1 = points[i].x;\n                const y1 = points[i].y;\n                // let totalHeight = hei;\n                let rectWidth = points[i].wid;\n                let currentWidth = 0;\n                let newWayPoint = [];\n                while (currentWidth <= rectWidth) {\n                    newWayPoint.push({ x: x1, y: y1, wid: currentWidth, hei: barHeight });\n                    let difference = rectWidth - currentWidth;\n                    currentWidth += difference < 15 && difference > 0 ? difference : 15;\n                }\n                wayPoints.push(newWayPoint);\n            }\n            return wayPoints;\n        };\n\n        const animate = (animateArr, t, cColor) => {\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = cColor;\n            ctx.fillRect(animateArr[t].x, animateArr[t].y, animateArr[t].wid, animateArr[t].hei);\n            ctx.closePath();\n            t = t + 1;\n            if (t < animateArr.length) {\n                requestAnimationFrame(animate.bind(this, animateArr, t, cColor));\n            }\n        };\n\n        const localLineCord = [];\n        for (let i = 0; i < data.datapoints.length; i++) {\n            // var rectHeight = barHeight;\n            const barChartWidth = (data.datapoints[i].value - range[0]) * horizontalCoefficient;\n            // let barChartWidth = barChartCount * barWidth + (barChartCount - 1) * 5;\n            let fromLeft = canvasWidthSpareForDetails;\n            let fromTop = i * spacingVertical + spacingVertical / 2 + curx - barHeight / 2 * barChartCount;\n            const newObj = {\n                x: fromLeft,\n                y: fromTop,\n                wid: barChartWidth,\n                hei: barHeight,\n                label: categories[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].value,\n                dataColor: data.chartColor\n            };\n            linecord.push(newObj);\n            localLineCord.push(newObj);\n        }\n\n        let points = calcWayPoints(localLineCord);\n\n        for (let i = 0; i < points.length; i++) {\n            let t = 0;\n            animate(points[i], t, chartColor);\n        }\n\n        return { linecord, barHeight };\n        // console.log(\"End : drawBar\");\n    } catch (e) {\n        console.log(\"error occurred in drawBar : \", e);\n    }\n}\n\nmodule.exports = drawBarChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/bar_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/column_chart_canvas.js":
/*!*****************************************************!*\
  !*** ./src/common/drawChart/column_chart_canvas.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawColumnChart(props) {\n    try {\n        // console.log(\"Start : drawBar\");\n        const canvasId = props.canvas;\n        const ctx = props.ctx_base;\n        const verticalNr = props.verticaldevisions;\n        const data = props.data;\n        const range = props.range;\n        const curx = props.nextcurve;\n        const chartColor = props.chartColor;\n        const columnCords = props.columnCords;\n        const columnChartCount = props.columnChartCount;\n        const maxTextWidth = props.hasOwnProperty(\"maxTextWidth\") ? props.maxTextWidth : 0;\n        const animation = props.hasOwnProperty(\"animate\") ? props.animate : true;\n\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingHorizontal = wid / data.datapoints.length;\n        const totalRange = range[1] - range[0];\n        const verticalCoefficient = hei / totalRange;\n        const barwidth = spacingHorizontal / columnChartCount * .60;\n\n        // ctx.globalCompositeOperation='destination-over';\n\n        const calcWayPoints = points => {\n            let wayPoints = [];\n            for (let i = 0; i < points.length; i++) {\n                let x1 = points[i].x;\n                let totalHeight = hei;\n                let rectHeight = points[i].hei;\n                let currentHeight = 0;\n                let newWayPoint = [];\n                while (currentHeight <= rectHeight) {\n                    newWayPoint.push({ x: x1, y: totalHeight - currentHeight, hei: currentHeight, wid: barwidth });\n                    let difference = rectHeight - currentHeight;\n                    currentHeight += difference < 15 && difference > 0 ? difference : 15;\n                }\n                wayPoints.push(newWayPoint);\n            }\n            return wayPoints;\n        };\n\n        const animate = (animateArr, t, cColor) => {\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = cColor;\n            ctx.fillRect(animateArr[t].x, animateArr[t].y, barwidth, animateArr[t].hei);\n            ctx.closePath();\n            t = t + 1;\n            if (t < animateArr.length) {\n                requestAnimationFrame(animate.bind(this, animateArr, t, cColor));\n            }\n        };\n\n        const localColumnCords = [];\n        for (let i = 0; i < data.datapoints.length; i++) {\n            const rectHeight = hei - (data.datapoints[i].y - range[0]) * verticalCoefficient;\n            let columnChartWidth = columnChartCount * barwidth + (columnChartCount - 1) * 5;\n            let fromLeft = canvasWidthSpareForDetails + i * spacingHorizontal + spacingHorizontal / 2 + curx - columnChartWidth / 2;\n            const newobj = {\n                x: fromLeft,\n                y: rectHeight,\n                wid: barwidth,\n                hei: hei - rectHeight,\n                label: data.datapoints[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].y,\n                dataColor: data.chartColor\n            };\n            columnCords.push(newobj);\n            localColumnCords.push(newobj);\n            if (!animation) {\n                ctx.beginPath();\n                ctx.globalAlpha = 1;\n                ctx.fillStyle = chartColor;\n                ctx.fillRect(newobj.x, newobj.y, barwidth, newobj.hei);\n                ctx.closePath();\n            }\n        }\n        if (animation) {\n            let points = calcWayPoints(localColumnCords);\n\n            for (let i = 0; i < points.length; i++) {\n                let t = 0;\n                animate(points[i], t, chartColor);\n            }\n        }\n\n        return { columnCords, barwidth };\n        // console.log(\"End : drawBar\");\n    } catch (e) {\n        console.log(\"error occurred in drawBar : \", e);\n    }\n}\n\nmodule.exports = drawColumnChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/column_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/doughnut_chart_canvas.js":
/*!*******************************************************!*\
  !*** ./src/common/drawChart/doughnut_chart_canvas.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function drawDoughnutChart(can, ctx, data, linecord, chartHeight) {\n    try {\n        // console.log(\"Start : drawDonut\");\n        const canvas = document.getElementById(can);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let linewidth = chartHeight / 4;\n        let radius = canvas.height / 2 - linewidth;\n        ctx.lineWidth = linewidth * 2;\n        let lastend = 0;\n        let myTotal = 0; // Automatically calculated so don't touch\n        for (let e = 0; e < data.datapoints.length; e++) {\n            myTotal += data.datapoints[e].y;\n        }\n        for (let i = 0; i < data.datapoints.length; i++) {\n            if (data.datapoints[i].y === 0) {\n                ctx.beginPath();\n                ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal), false);\n                ctx.strokeStyle = '#fff';\n                ctx.stroke();\n            }\n            ctx.strokeStyle = data.datapoints[i].color;\n            ctx.beginPath();\n            ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal), false);\n            var newobj = {\n                hei: canvas.height,\n                wid: canvas.width,\n                startangle: lastend,\n                lastangle: lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal),\n                label: data.datapoints[i].label,\n                y: data.datapoints[i].y\n            };\n            linecord.push(newobj);\n            lastend += Math.PI * 2 * (data.datapoints[i].y / myTotal);\n            ctx.stroke();\n        }\n        /* Draw piechart number values */\n        let angle = 0;\n        let x = Math.floor(canvas.width / 2);\n        let y = Math.floor(canvas.height / 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.font = radius * 0.12 + \"px arial\";\n        let anglenew;\n        for (let i = 0; i < data.datapoints.length; i++) {\n            if (data.datapoints[i].y != 0) {\n                anglenew = Math.PI * 2 * (data.datapoints[i].y / myTotal);\n                let angleMiddle = anglenew / 3;\n                let fx = canvas.width / 2 + radius * Math.cos(angle + angleMiddle);\n                let fy = radius * 1.5 + radius * Math.sin(angle + angleMiddle);\n                ctx.translate(fx, fy);\n                ctx.fillText(data.datapoints[i].y.toString(), 0, 0 /*x + radius / 1.3, y*/);\n                ctx.translate(-fx, -fy);\n                angle += Math.PI * 2 * (data.datapoints[i].y / myTotal);\n            }\n        }\n        return linecord;\n        // console.log(\"End : drawDonut\");\n    } catch (e) {\n        console.log(\"error occurred in drawDonut : \", e);\n    }\n}\n\nmodule.exports = drawDoughnutChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/doughnut_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/line_chart_canvas.js":
/*!***************************************************!*\
  !*** ./src/common/drawChart/line_chart_canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nlet canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawLineChart(canvasId, ctx, verticalNr, data, range, chartColor, linecord, maxTextWidth) {\n    try {\n        // console.log(\"Start : drawGraphicLinear\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        const commonCodeCircle = () => {\n            ctx.beginPath();\n            ctx.fillStyle = chartColor;\n            ctx.arc(points[t].x, points[t].y, 8, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n        };\n\n        const fillAreaCall = vertices => {\n            ctx.beginPath();\n            if (vertices.length) {\n                ctx.moveTo(vertices[0].x, hei);\n            }\n            for (let points = 0; points < vertices.length; points++) {\n                ctx.lineTo(vertices[points].x, vertices[points].y + 4);\n            }\n            if (vertices.length) {\n                ctx.lineTo(vertices[vertices.length - 1].x, hei);\n            }\n            ctx.closePath();\n            ctx.globalAlpha = 0.3;\n            ctx.fillStyle = chartColor;\n            ctx.fill();\n        };\n\n        const calcWayPoints = vertices => {\n            let wayPoints = [];\n            for (let i = 1; i < vertices.length; i++) {\n                let pt0 = vertices[i - 1];\n                let pt1 = vertices[i];\n                let dx = pt1.x - pt0.x;\n                let dy = pt1.y - pt0.y;\n                for (let j = 0; j < differencePoints; j++) {\n                    let x = pt0.x + dx * j / differencePoints;\n                    let y = pt0.y + dy * j / differencePoints;\n                    wayPoints.push({\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n            return wayPoints;\n        };\n\n        const animate = () => {\n            if (t < points.length - 1) {\n                requestAnimationFrame(animate);\n            }\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = chartColor;\n            if (t === 0) {\n                ctx.moveTo(points[t].x, points[t].y);\n            } else {\n                ctx.moveTo(points[t - 1].x, points[t - 1].y);\n                ctx.lineTo(points[t].x, points[t].y);\n            }\n            ctx.stroke();\n            // increment \"t\" to get the next waypoint\n            if (t % differencePoints === 0 || t === points.length - 1) {\n                commonCodeCircle();\n            }\n            if (data.fill) {\n                let p = {};\n                if (t) {\n                    p = points.slice(t - 1, t + 1);\n                }\n                fillAreaCall(p);\n            }\n            t += 1;\n        };\n\n        var canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        const spacingHorizontal = wid / data.datapoints.length;\n\n        const totalRange = range[1] - range[0];\n        const verticalCoefficient = hei / totalRange;\n        ctx.beginPath();\n        const localLineCords = [];\n        for (let i = 0; i < data.datapoints.length; i++) {\n            let newObj = {\n                x: i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails,\n                y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient,\n                label: data.datapoints[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].y,\n                dataColor: data.chartColor\n            };\n            // This linecord contains multiple charts data ponts for the visualization purpose of on hover.\n            linecord.push(newObj);\n            localLineCords.push(newObj);\n        }\n        let t = 0;\n        let differencePoints = 25;\n        let points = calcWayPoints(localLineCords);\n\n        points.push(localLineCords[localLineCords.length - 1]);\n\n        animate();\n\n        ctx.globalAlpha = 1;\n        return linecord;\n    } catch (e) {\n        console.log(\"error occured in drawGraphicLinear : \", e);\n    }\n}\n\nmodule.exports = drawLineChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/line_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/meter_chart_canvas.js":
/*!****************************************************!*\
  !*** ./src/common/drawChart/meter_chart_canvas.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst xAxisSpacing = gkChartConsts.xAxisSpacing;\nconst fontLineHeight = gkChartConsts.fontLineHeight;\nconst blackFillStyle = gkChartConsts.blackFillStyle;\nconst font = gkChartConsts.font;\nconst white = gkChartConsts.white;\n\nfunction drawMeterChart(can, ctx, verticalNr, data, range, chartColor, ChartDataToShow) {\n    try {\n        // console.log(\"Start : drawMeter\");\n        let linecord = [];\n        const canvas = document.getElementById(can);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let linewidth = 50;\n        ctx.lineWidth = 4;\n        let lastend = 3.141592653589793;\n        let myTotal = 0; // Automatically calculated so don't touch\n        let radius = canvas.height / 2 - linewidth;\n        for (let e = 0; e < data.datapoints.length; e++) {\n            myTotal += data.datapoints[e].y;\n        }\n        for (let i = 0; i < data.datapoints.length; i++) {\n            ctx.strokeStyle = white;\n            ctx.fillStyle = data.datapoints[i].color;\n            ctx.beginPath();\n            ctx.moveTo(canvas.width / 2, canvas.height / 2);\n            ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + Math.PI * (data.datapoints[i].y / myTotal));\n            //// console.log(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)));\n            ctx.lineTo(canvas.width / 2, canvas.height / 2);\n            ctx.fill();\n            ctx.stroke();\n            var newobj = {\n                x: canvas.width / 2,\n                startangle: lastend,\n                lastangle: lastend + Math.PI * (data.datapoints[i].y / myTotal),\n                label: data.datapoints[i].label\n            };\n            linecord.push(newobj);\n            lastend += Math.PI * (data.datapoints[i].y / myTotal);\n        }\n        ctx.beginPath();\n        ctx.fillStyle = white;\n        ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.7, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.closePath();\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n        ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.1, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.closePath();\n        ctx.beginPath();\n        var rotateangel = Math.PI * (ChartDataToShow / 100) + 3.141592653589793;\n        var headlen = 10;\n        ctx.lineWidth = 6;\n        ctx.lineCap = \"round\";\n        var tox = canvas.width / 2 + radius * .8 * Math.cos(rotateangel);\n        var toy = canvas.height / 2 + radius * .8 * Math.sin(rotateangel);\n        var fromx = canvas.width / 2;\n        var fromy = canvas.height / 2;\n        ctx.moveTo(canvas.width / 2, canvas.height / 2);\n        ctx.lineTo(tox, toy);\n        ctx.strokeStyle = blackFillStyle;\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.fillStyle = white;\n        ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.07, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.closePath();\n\n        /* Draw piechart number values */\n        let angle = 3.141592653589793;\n        let x = Math.floor(canvas.width / 2);\n        let y = Math.floor(canvas.height / 2);\n        ctx.fillStyle = blackFillStyle;\n        ctx.font = font;\n        ctx.save();\n\n        /*Text in data format loop*/\n        var anglenew;\n        for (let i = 0; i < data.datapoints.length; i++) {\n            anglenew = Math.PI * 2 * (data.datapoints[i].y / myTotal) / 2;\n            let angleMiddle = anglenew / 6;\n            let fx = canvas.width / 2 + radius * 1.01 * Math.cos(angle + angleMiddle);\n            let fy = canvas.height / 2 + radius * 1.01 * Math.sin(angle + angleMiddle);\n            ctx.translate(fx, fy);\n            ctx.rotate(angle + 1.8);\n            ctx.fillText(data.datapoints[i].label.toString(), 0, 0);\n            ctx.rotate(-(angle + 1.8));\n            ctx.translate(-fx, -fy);\n            angle += Math.PI * (data.datapoints[i].y / myTotal);\n        }\n        ctx.restore();\n        return linecord;\n        // console.log(\"End : drawMeter\");\n    } catch (e) {\n        console.log(\"error occured in drawMeter : \", e);\n    }\n}\n\nmodule.exports = drawMeterChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/meter_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/pie_chart_canvas.js":
/*!**************************************************!*\
  !*** ./src/common/drawChart/pie_chart_canvas.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function drawPieChart(can, ctx, data, linecord) {\n    try {\n        // console.log(\"Start : drawPie\");\n        const canvas = document.getElementById(can);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let lastend = 0;\n        let myTotal = 0; // Automatically calculated so don't touch\n        let radius = canvas.height / 2;\n        for (let e = 0; e < data.datapoints.length; e++) {\n            myTotal += data.datapoints[e].y;\n        }\n        for (let i = 0; i < data.datapoints.length; i++) {\n            ctx.fillStyle = data.datapoints[i].color;\n            ctx.beginPath();\n            ctx.moveTo(canvas.width / 2, canvas.height / 2);\n            if (data.datapoints[i].y === 0) {\n                ctx.arc(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal), false);\n                ctx.lineTo(canvas.width / 2, canvas.height / 2);\n                ctx.strokeStyle = '1';\n                ctx.strokeStyle = '#fff';\n                ctx.stroke();\n            }\n            ctx.arc(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal), false);\n            ctx.lineTo(canvas.width / 2, canvas.height / 2);\n            var newobj = {\n                wid: canvas.width,\n                hei: canvas.height,\n                startangle: lastend,\n                lastangle: lastend + Math.PI * 2 * (data.datapoints[i].y / myTotal),\n                label: data.datapoints[i].label,\n                y: data.datapoints[i].y\n            };\n            linecord.push(newobj);\n            lastend += Math.PI * 2 * (data.datapoints[i].y / myTotal);\n            ctx.fill();\n        }\n        /* Draw pieChart number values and numbers*/\n        let angle = 0;\n        let x = Math.floor(canvas.width / 2);\n        let y = Math.floor(canvas.height / 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.font = radius * 0.10 + \"px arial\";\n        var anglenew;\n        for (let i = 0; i < data.datapoints.length; i++) {\n            if (data.datapoints[i].y !== 0) {\n                anglenew = Math.PI * 2 * (data.datapoints[i].y / myTotal);\n                let angleMiddle = anglenew / 3;\n                let fx = canvas.width / 2 + radius * .7 * Math.cos(angle + angleMiddle);\n                let fy = radius + radius * .7 * Math.sin(angle + angleMiddle);\n                ctx.translate(fx, fy);\n                ctx.fillText(data.datapoints[i].y.toString(), 0, 0 /*x + radius / 1.3, y*/);\n                ctx.translate(-fx, -fy);\n                angle += Math.PI * 2 * (data.datapoints[i].y / myTotal);\n            }\n        }\n        return linecord;\n        // console.log(\"End : drawPie\");\n    } catch (e) {\n        console.log(\"error occurred in drawPie : \", e);\n    }\n}\n\nmodule.exports = drawPieChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/pie_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/smooth_line_chart_canvas.js":
/*!**********************************************************!*\
  !*** ./src/common/drawChart/smooth_line_chart_canvas.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction bezierPointsCalc(a, f) {\n    for (var b = [], c, e = 0; e < a.length; e++) if (0 == e) b.push(a[0]);else {\n        var g, h, l;\n        l = e - 1;\n        g = 0 === l ? 0 : l - 1;\n        h = l === a.length - 1 ? l : l + 1;\n        c = Math.abs((a[h].x - a[g].x) / (0 === a[h].x - a[l].x ? 0.01 : a[h].x - a[l].x)) * (f - 1) / 2 + 1;\n        var t = (a[h].x - a[g].x) / c;\n        c = (a[h].y - a[g].y) / c;\n        b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? {\n            x: a[l].x + t / 3,\n            y: a[l].y + c / 3\n        } : {\n            x: a[l].x,\n            y: a[l].y + c / 9\n        };\n        l = e;\n        g = 0 === l ? 0 : l - 1;\n        h = l === a.length - 1 ? l : l + 1;\n        c = Math.abs((a[h].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (f - 1) / 2 + 1;\n        t = (a[h].x - a[g].x) / c;\n        c = (a[h].y - a[g].y) / c;\n        b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? {\n            x: a[l].x - t / 3,\n            y: a[l].y - c / 3\n        } : {\n            x: a[l].x,\n            y: a[l].y - c / 9\n        };\n        b[b.length] = a[e];\n    }\n    return b;\n}\n\nfunction drawSmoothLineChart(canvasId, ctx, verticalNr, data, range, chartColor, linecord, maxTextWidth) {\n    try {\n        // console.log(\"Start : drawGraphicLinear\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const calcWayPoints = vertices => {\n            const wayPoints = [];\n            for (let i = 1; i < vertices.length; i += 3) {\n                let startPt = { x: vertices[i - 1].x, y: vertices[i - 1].y };\n                let ct1 = { x: vertices[i].x, y: vertices[i].y };\n                let ct2 = { x: vertices[i + 1].x, y: vertices[i + 1].y };\n                let endPt = { x: vertices[i + 2].x, y: vertices[i + 2].y };\n                for (let t = 0; t < difference; t++) {\n                    let pointers = getQuadraticBezierXYatT(startPt, ct1, ct2, endPt, t / difference);\n                    wayPoints.push({\n                        x: pointers.x,\n                        y: pointers.y\n                    });\n                }\n            }\n            return wayPoints;\n        };\n\n        const getQuadraticBezierXYatT = (startPt, ct1, ct2, endPt, t) => {\n            let x = Math.pow(1 - t, 3) * startPt.x + 3 * Math.pow(1 - t, 2) * t * ct1.x + 3 * (1 - t) * Math.pow(t, 2) * ct2.x + Math.pow(t, 3) * endPt.x;\n            let y = Math.pow(1 - t, 3) * startPt.y + 3 * Math.pow(1 - t, 2) * t * ct1.y + 3 * (1 - t) * Math.pow(t, 2) * ct2.y + Math.pow(t, 3) * endPt.y;\n            return { x: x, y: y };\n        };\n\n        const commonCodeCircle = () => {\n            ctx.beginPath();\n            ctx.fillStyle = chartColor;\n            ctx.arc(points[i].x, points[i].y, 8, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.strokeStyle = chartColor;\n            ctx.stroke();\n        };\n\n        const fillAreaCall = vertices => {\n            ctx.beginPath();\n            if (vertices.length) {\n                ctx.moveTo(vertices[0].x, hei);\n            }\n            for (let points = 0; points < vertices.length; points++) {\n                ctx.lineTo(vertices[points].x, vertices[points].y + 4);\n            }\n            if (vertices.length) {\n                ctx.lineTo(vertices[vertices.length - 1].x, hei);\n            }\n            ctx.closePath();\n            ctx.globalAlpha = 0.3;\n            ctx.fillStyle = chartColor;\n            ctx.fill();\n        };\n\n        const animate = points => {\n            if (i < points.length - 1) {\n                requestAnimationFrame(animate.bind(this, points));\n            }\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = chartColor;\n            if (i === 0) {\n                ctx.moveTo(points[i].x, points[i].y);\n            } else {\n                ctx.moveTo(points[i - 1].x, points[i - 1].y);\n                ctx.lineTo(points[i].x, points[i].y);\n            }\n            ctx.stroke();\n\n            if (i % difference === 0 || i === points.length - 1) {\n                commonCodeCircle();\n            }\n\n            if (data.fill) {\n                let p = {};\n                if (i) {\n                    p = points.slice(i - 1, i + 1);\n                }\n                fillAreaCall(p);\n            }\n\n            i = i + 1;\n        };\n\n        var canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - +canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        var spacingHorizontal = wid / data.datapoints.length;\n\n        const totalRange = range[1] - range[0];\n        const verticalCoefficient = hei / totalRange;\n        ctx.strokeStyle = chartColor;\n        ctx.globalAlpha = 1;\n        const localLineCords = [];\n\n        for (let i = 0; i < data.datapoints.length; i++) {\n            let newobj = {\n                x: i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails,\n                y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient,\n                label: data.datapoints[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].y,\n                dataColor: data.chartColor\n            };\n            linecord.push(newobj);\n            localLineCords.push(newobj);\n        }\n\n        ctx.closePath();\n        let f = 2;\n        let a = bezierPointsCalc(localLineCords, f);\n        // console.log(a);\n\n        let difference = 25;\n        let points = calcWayPoints(a);\n\n        points.push(localLineCords[localLineCords.length - 1]);\n\n        let i = 0;\n\n        animate(points);\n\n        ctx.globalAlpha = 1;\n\n        return linecord;\n    } catch (e) {\n        console.log(\"error occured in drawsplinechart : \", e);\n    }\n}\n\nmodule.exports = drawSmoothLineChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/smooth_line_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/stacked_bar_chart_canvas.js":
/*!**********************************************************!*\
  !*** ./src/common/drawChart/stacked_bar_chart_canvas.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawStackedBarChart(props) {\n    try {\n        // console.log(\"Start : drawBar\");\n        // const canvasId = props.canvasId;\n        // const ctx = props. ctx_base;\n        // const verticalNr = props.verticalNr;\n        // const data = props.data;\n        // const range = props.rangedata;\n        // const curx = props.nextcurve;\n        // const chartColor = props.chartColor;\n        // const barCords = props.barCords;\n        // const barChartCount = props.barChartCount;\n        // const chartDataLength = props.chartDataLength;\n        // const maxTextWidth = props.maxTextWidth;\n        // const categories = props.categories;\n        // const chart = props.chart;\n\n        const canvasId = props.canvasId;\n        const ctx = props.ctx_base;\n        const verticalNr = props.verticalNr;\n        const chart = props.chart;\n        const renderCount = props.renderCount;\n        const range = props.range;\n        const curx = props.nextCurve;\n        const chartColor = props.chartColor;\n        const barCords = props.barCords;\n        const barChartCount = props.barChartCount;\n        const maxTextWidth = props.hasOwnProperty(\"maxTextWidth\") ? props.maxTextWidth : 0;\n        const animation = props.hasOwnProperty(\"animate\") ? props.animate : false; // Todo: mark default value again as true\n\n\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const categoriesLength = chart.categories.length;\n\n        const spacingVertical = hei / categoriesLength;\n        const totalRange = range[1] - range[0];\n        // const verticalCoefficient = hei / totalRange;\n        const horizontalCoefficient = wid / totalRange;\n        const barHeight = spacingVertical / barChartCount * .80;\n\n        const calcWayPoints = points => {\n            let wayPoints = [];\n            for (let i = 0; i < points.length; i++) {\n                const x1 = points[i].x;\n                const y1 = points[i].y;\n                // let totalHeight = hei;\n                let rectWidth = points[i].wid;\n                let currentWidth = 0;\n                let newWayPoint = [];\n                while (currentWidth <= rectWidth) {\n                    newWayPoint.push({ x: x1, y: y1, wid: currentWidth, hei: barHeight });\n                    let difference = rectWidth - currentWidth;\n                    currentWidth += difference < 15 && difference > 0 ? difference : 15;\n                }\n                wayPoints.push(newWayPoint);\n            }\n            return wayPoints;\n        };\n\n        const animate = (animateArr, t, cColor) => {\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = cColor;\n            ctx.fillRect(animateArr[t].x, animateArr[t].y, animateArr[t].wid, animateArr[t].hei);\n            ctx.closePath();\n            t = t + 1;\n            if (t < animateArr.length) {\n                requestAnimationFrame(animate.bind(this, animateArr, t, cColor));\n            }\n        };\n\n        const localBarCords = [];\n        const dataSet = chart.data[renderCount].dataSet;\n        const renderStackCount = dataSet.length;\n\n        for (let i = 0; i < categoriesLength; i++) {\n            // var rectHeight = barHeight;\n            let startWidth = 0;\n            const newObj = [];\n            let fromTop = i * spacingVertical + spacingVertical / 2 + curx - barHeight / 2 * barChartCount;\n            for (let j = 0; j < renderStackCount; j++) {\n                const currentValue = dataSet[j].dataPoints[i].value;\n                const currentRectWidth = (currentValue - range[0]) * horizontalCoefficient;\n                let fromLeft = canvasWidthSpareForDetails + startWidth;\n                startWidth += currentRectWidth;\n\n                newObj.push({\n                    x: fromLeft,\n                    y: fromTop,\n                    wid: currentRectWidth,\n                    hei: barHeight,\n                    label: chart.categories[i].label,\n                    dataLabel: dataSet[j].dataLabel,\n                    dataval: currentValue,\n                    dataColor: dataSet[j].color\n                });\n                if (!animation) {\n                    ctx.beginPath();\n                    ctx.globalAlpha = 1;\n                    ctx.fillStyle = dataSet[j].color;\n                    ctx.fillRect(newObj[j].x, newObj[j].y, newObj[j].wid, newObj[j].hei);\n                    ctx.closePath();\n                }\n            }\n\n            // let barChartWidth = barChartCount * barWidth + (barChartCount - 1) * 5;\n\n            barCords.push(newObj);\n            localBarCords.push(newObj);\n        }\n        if (animation) {\n            let points = calcWayPoints(localBarCords);\n\n            for (let i = 0; i < points.length; i++) {\n                let t = 0;\n                animate(points[i], t, chartColor);\n            }\n        }\n\n        return { barCords, barHeight };\n        // console.log(\"End : drawBar\");\n    } catch (e) {\n        console.log(\"error occurred in drawBar : \", e);\n    }\n}\n\nmodule.exports = drawStackedBarChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/stacked_bar_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/stacked_chart_canvas.js":
/*!******************************************************!*\
  !*** ./src/common/drawChart/stacked_chart_canvas.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawStackedChart(props) {\n    try {\n        // console.log(\"Start : drawBar\");\n        const canvasId = props.canvasId;\n        const ctx = props.ctx_base;\n        // const verticalNr = props.verticalNr;\n        const chart = props.chart;\n        const renderCount = props.renderCount;\n        const range = props.range;\n        const curx = props.nextCurve;\n        // const chartColor = props.chartColor;\n        const columnCords = props.columnCords;\n        const columnChartCount = props.columnChartCount;\n        const maxTextWidth = props.hasOwnProperty(\"maxTextWidth\") ? props.maxTextWidth : 0;\n        const animation = props.hasOwnProperty(\"animate\") ? props.animate : false; // Todo: mark default value again as true\n\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const horizontalDivision = chart.categories.length;\n        const spacingHorizontal = wid / horizontalDivision;\n        const totalRange = range[1] - range[0];\n        const verticalCoefficient = hei / totalRange;\n        const barWidth = spacingHorizontal / columnChartCount * .60;\n\n        // ctx.globalCompositeOperation='destination-over';\n\n        const calcWayPoints = points => {\n            let wayPoints = [];\n            for (let i = 0; i < points.length; i++) {\n                let x1 = points[i].x;\n                let totalHeight = hei;\n                let rectHeight = points[i].hei;\n                let currentHeight = 0;\n                let newWayPoint = [];\n                while (currentHeight <= rectHeight) {\n                    newWayPoint.push({ x: x1, y: totalHeight - currentHeight, hei: currentHeight, wid: barwidth });\n                    let difference = rectHeight - currentHeight;\n                    currentHeight += difference < 15 && difference > 0 ? difference : 15;\n                }\n                wayPoints.push(newWayPoint);\n            }\n            return wayPoints;\n        };\n\n        const animate = (animateArr, t, cColor) => {\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = cColor;\n            ctx.fillRect(animateArr[t].x, animateArr[t].y, barwidth, animateArr[t].hei);\n            ctx.closePath();\n            t = t + 1;\n            if (t < animateArr.length) {\n                requestAnimationFrame(animate.bind(this, animateArr, t, cColor));\n            }\n        };\n\n        const localColumnCords = [];\n        const dataSet = chart.data[renderCount].dataSet;\n        const renderStackCount = dataSet.length;\n\n        for (let i = 0; i < horizontalDivision; i++) {\n            let startHeight = 0;\n            const newObj = [];\n            for (let j = 0; j < renderStackCount; j++) {\n                const currentValue = dataSet[j].dataPoints[i].value;\n                const currentRectHeight = (currentValue - range[0]) * verticalCoefficient;\n                startHeight += currentRectHeight;\n                const rectHeight = hei - startHeight;\n                let columnChartWidth = columnChartCount * barWidth + (columnChartCount - 1) * 5;\n                let fromLeft = canvasWidthSpareForDetails + i * spacingHorizontal + spacingHorizontal / 2 + curx - columnChartWidth / 2;\n                newObj.push({\n                    x: fromLeft,\n                    y: rectHeight,\n                    wid: barWidth,\n                    hei: currentRectHeight,\n                    label: chart.categories[i].label,\n                    dataLabel: dataSet[j].dataLabel,\n                    dataVal: currentValue,\n                    dataColor: dataSet[j].color\n                });\n                if (!animation) {\n                    ctx.beginPath();\n                    ctx.globalAlpha = 1;\n                    ctx.fillStyle = dataSet[j].color;\n                    ctx.fillRect(newObj[j].x, newObj[j].y, barWidth, newObj[j].hei);\n                    ctx.closePath();\n                }\n            }\n            columnCords.push(newObj);\n            localColumnCords.push(newObj);\n        }\n        if (animation) {\n            let points = calcWayPoints(localColumnCords);\n\n            for (let i = 0; i < points.length; i++) {\n                let t = 0;\n                animate(points[i], t, chartColor);\n            }\n        }\n\n        return { columnCords, barWidth };\n        // console.log(\"End : drawBar\");\n    } catch (e) {\n        console.log(\"error occurred in drawBar : \", e);\n    }\n}\n\nmodule.exports = drawStackedChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/stacked_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawChart/step_chart_canvas.js":
/*!***************************************************!*\
  !*** ./src/common/drawChart/step_chart_canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction DrawStepChart(canvasId, ctx, verticalNr, data, range, chartColor, linecord, maxTextWidth = 0) {\n    try {\n        // console.log(\"Start : drawStepchart\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const calcWayPoints = vertices => {\n            const wayPoints = [];\n            for (var i = 1; i < vertices.length; i++) {\n                var pt0 = vertices[i - 1];\n                var pt1 = vertices[i];\n                var dx = pt1.x - pt0.x;\n                var dy = pt1.y - pt0.y;\n                for (var j = 0; j < differencePoints; j++) {\n                    var x = pt0.x + dx * j / differencePoints;\n                    var y = pt0.y + dy * j / differencePoints;\n                    wayPoints.push({\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n            return wayPoints;\n        };\n\n        const fillAreaCall = vertices => {\n            ctx.beginPath();\n            if (vertices.length) {\n                ctx.moveTo(vertices[0].x, hei);\n            }\n            for (let points = 0; points < vertices.length; points++) {\n                ctx.lineTo(vertices[points].x, vertices[points].y + 4);\n            }\n            if (vertices.length) {\n                ctx.lineTo(vertices[vertices.length - 1].x, hei);\n            }\n            ctx.closePath();\n            ctx.globalAlpha = 0.1;\n            ctx.fillStyle = chartColor;\n            ctx.fill();\n        };\n\n        const commonCodeCircle = () => {\n            ctx.beginPath();\n            ctx.fillStyle = chartColor;\n            ctx.arc(points[t].x, points[t].y, 8, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n        };\n\n        const animate = () => {\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = chartColor;\n            if (t < points.length - 1) {\n                requestAnimationFrame(animate);\n            }\n            // draw a line segment from the last waypoint\n            // to the current waypoint\n            ctx.beginPath();\n            if (t === 0) {\n                ctx.moveTo(points[t].x, points[t].y);\n            } else {\n                ctx.moveTo(points[t - 1].x, points[t - 1].y);\n                ctx.lineTo(points[t].x, points[t].y);\n            }\n            ctx.stroke();\n            // increment \"t\" to get the next waypoint\n            if (t % (differencePoints * 2) === 0 || t === points.length - 1) {\n                commonCodeCircle();\n            }\n            if (data.fill) {\n                let p = {};\n                if (t) {\n                    p = points.slice(t - 1, t + 1);\n                }\n                fillAreaCall(p);\n            }\n            t += 1;\n        };\n\n        var canvas = document.getElementById(canvasId);\n        var hei = canvas.height - canvasHeightSpareForDetails;\n        var wid = canvas.width - +canvasWidthSpareForDetails;\n        var spacingVertical = hei / verticalNr;\n        var spacingHorizontal = wid / data.datapoints.length;\n\n        var totalRange = range[1] - range[0];\n        var verticalCoefficient = hei / totalRange;\n\n        ctx.beginPath();\n        var localLineCords = [];\n        for (let i = 0; i < data.datapoints.length; i++) {\n            var newobj = {\n                x: i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails,\n                y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient,\n                label: data.datapoints[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].y,\n                dataColor: data.chartColor\n            };\n            linecord.push(newobj);\n            localLineCords.push(newobj);\n        }\n\n        ctx.beginPath();\n        ctx.globalAlpha = 1;\n        ctx.strokeStyle = chartColor;\n        let lPoints = [];\n        const lineCordsLength = localLineCords.length;\n        for (let i = 0; i < lineCordsLength; i++) {\n            if (i === 0) {\n                lPoints.push({ x: localLineCords[i].x, y: localLineCords[i].y });\n            } else {\n                lPoints.push({ x: localLineCords[i].x, y: localLineCords[i - 1].y });\n                lPoints.push({ x: localLineCords[i].x, y: localLineCords[i].y });\n            }\n        }\n\n        let t = 0;\n        let differencePoints = 15;\n        let points = calcWayPoints(lPoints);\n\n        points.push(localLineCords[localLineCords.length - 1]);\n\n        animate();\n\n        ctx.globalAlpha = 1;\n\n        return linecord;\n        // console.log(\"End : drawStepchart\");\n    } catch (e) {\n        console.log(\"error occured in drawGraphicLinear : \", e);\n    }\n}\n\nmodule.exports = DrawStepChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/step_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/bar_chart_upper_canvas.js":
/*!*************************************************************!*\
  !*** ./src/common/drawUpperChart/bar_chart_upper_canvas.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nconst gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction BarChartUpperCanvas(nr, ctx, linecord, container, chart, maxTextWidth) {\n    try {\n        // console.log(\"Start : barChartUpperCanvas\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n\n        let dataPointLen = chart.data[0].datapoints.length;\n        let wid = document.getElementById('canvasupper' + nr).width - canvasWidthSpareForDetails;\n        let hei = document.getElementById('canvasupper' + nr).height - canvasHeightSpareForDetails;\n        const spacingHorizontal = wid / dataPointLen;\n        const spacingVertical = hei / dataPointLen;\n        let lineCordRepeat = linecord.length / dataPointLen;\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        const canvasUpperHeight = canvasUpper.height;\n        // const barHeight = spacingVertical / lineCordRepeat * .80;\n        // const canvasUpperWidth = canvasUpper.width;\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                let mousePos = GetMousePos(canvasUpper, evt);\n                let details = '';\n                for (let i = 0; i < dataPointLen; i++) {\n                    ctx.beginPath();\n                    let x1 = canvasWidthSpareForDetails;\n                    let x2 = wid;\n                    let y1 = i * spacingVertical;\n                    let y2 = spacingVertical;\n                    ctx.rect(x1, y1, x2, y2);\n\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        ctx.beginPath();\n                        ctx.rect(x1, y1, x2, y2);\n                        ctx.fillStyle = 'rgba(0,0,0,.1)';\n                        ctx.fill();\n                        ctx.closePath();\n                        for (let j = 0; j < lineCordRepeat; j++) {\n                            let position = j * dataPointLen + i;\n                            if (chartToolTip) {\n                                cssStyle(chartToolTip, {\n                                    \"left\": mousePos.x / ratio(ctx) + 30 + \"px\",\n                                    \"top\": mousePos.y / ratio(ctx) + 30 + \"px\",\n                                    \"display\": \"block\"\n                                });\n                            }\n                            details += `<div style=\"color: ${linecord[position].dataColor}\">${linecord[position].dataLabel} - ${linecord[position].label} : <b>${linecord[position].dataval}</b> <br /></div>`;\n                        }\n                        ctx.beginPath();\n                        let lineX = x1 + spacingHorizontal / 2;\n                        ctx.strokeStyle = strokeStyle;\n                        ctx.lineWidth = 1;\n                        ctx.moveTo(lineX, y1);\n                        ctx.stroke();\n                        chartToolTip.innerHTML = details;\n                        break;\n                    }\n                    ctx.closePath();\n                }\n            }.bind(this), false);\n        }\n        // console.log(\"End : barChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in barChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = BarChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/bar_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/clear_upper_canvas_details.js":
/*!*****************************************************************!*\
  !*** ./src/common/drawUpperChart/clear_upper_canvas_details.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n\nfunction ClearDetails(nr, ctx, container) {\n    const canvasUpperNr = document.getElementById('canvasupper' + nr);\n    if (canvasUpperNr) {\n        canvasUpperNr.addEventListener('mousemove', function (evt) {\n            ctx.clearRect(0, 0, canvasUpperNr.width, canvasUpperNr.height);\n        }.bind(this));\n\n        canvasUpperNr.addEventListener('mouseout', function (evt) {\n            setTimeout(function () {\n                ctx.clearRect(0, 0, canvasUpperNr.width, canvasUpperNr.height);\n                const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n                if (chartToolTip) {\n                    cssStyle(chartToolTip, {\n                        'display': 'none'\n                    });\n                }\n            }, 2000);\n        }.bind(this));\n    }\n}\n\nmodule.exports = ClearDetails;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/clear_upper_canvas_details.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/column_chart_upper_canvas.js":
/*!****************************************************************!*\
  !*** ./src/common/drawUpperChart/column_chart_upper_canvas.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nconst gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction columnChartUpperCanvas(nr, ctx, linecord, container, chart, maxTextWidth = 0) {\n    try {\n        // console.log(\"Start : barChartUpperCanvas\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        let dataPointLen = chart.data[0].datapoints.length;\n        let wid = document.getElementById('canvasupper' + nr).width - canvasWidthSpareForDetails;\n        const spacingHorizontal = wid / dataPointLen;\n        let lineCordRepeat = linecord.length / dataPointLen;\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        const canvasUpperHeight = canvasUpper.height;\n        // const canvasUpperWidth = canvasUpper.width;\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                let mousePos = GetMousePos(canvasUpper, evt);\n                let details = '';\n                for (let i = 0; i < dataPointLen; i++) {\n                    ctx.beginPath();\n                    let x1 = i * spacingHorizontal + canvasWidthSpareForDetails;\n                    let x2 = spacingHorizontal;\n                    let y1 = 0;\n                    let y2 = canvasUpperHeight - canvasHeightSpareForDetails;\n                    ctx.rect(x1, y1, x2, y2);\n\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        ctx.beginPath();\n                        ctx.rect(x1, y1, x2, y2);\n                        ctx.fillStyle = 'rgba(0,0,0,.05)';\n                        ctx.fill();\n                        ctx.closePath();\n                        for (let j = 0; j < lineCordRepeat; j++) {\n                            let position = j * dataPointLen + i;\n                            // ctx.beginPath();\n                            // ctx.rect(linecord[position].x, linecord[position].y, linecord[position].wid, linecord[position].hei);\n                            // ctx.lineWidth = .5;\n                            // ctx.fillStyle = 'rgba(0,0,0,.3)';\n                            // ctx.fill();\n                            // ctx.stroke();\n                            if (chartToolTip) {\n                                cssStyle(chartToolTip, {\n                                    \"left\": mousePos.x / ratio(ctx) + 30 + \"px\",\n                                    \"top\": mousePos.y / ratio(ctx) + \"px\",\n                                    \"display\": \"block\"\n                                });\n                            }\n                            details += `<div style=\"color: ${linecord[position].dataColor}\">${linecord[position].dataLabel}  <br />  ${linecord[position].label} : ${linecord[position].dataval} <br /></div>`;\n                        }\n                        ctx.beginPath();\n                        let lineX = x1 + spacingHorizontal / 2;\n                        ctx.strokeStyle = strokeStyle;\n                        ctx.lineWidth = 1;\n                        ctx.moveTo(lineX, y1);\n                        ctx.stroke();\n                        chartToolTip.innerHTML = details;\n                        break;\n                    }\n                    ctx.closePath();\n                }\n            }.bind(this), false);\n        }\n        // console.log(\"End : barChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in barChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = columnChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/column_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/doughnut_chart_upper_canvas.js":
/*!******************************************************************!*\
  !*** ./src/common/drawUpperChart/doughnut_chart_upper_canvas.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nfunction DoughnutChartUpperCanvas(nr, ctx, linecord, container) {\n    try {\n        // console.log(\"Start : donutChartUpperCanvas\");\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        const canvasUpperHeight = canvasUpper.height;\n        const canvasUpperWidth = canvasUpper.width;\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                let linewidth = 80;\n                let mousePos = GetMousePos(canvasUpper, evt);\n                for (let i = 0; i < linecord.length; i++) {\n                    let radius = linecord[i].hei / 2 - linewidth;\n                    ctx.lineWidth = linewidth * 2;\n                    ctx.beginPath();\n                    ctx.arc(linecord[i].wid / 2, linecord[i].hei / 2, radius, linecord[i].startangle, linecord[i].lastangle, false);\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y)) {\n                        ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                        ctx.stroke();\n                        if (chartToolTip) {\n                            cssStyle(chartToolTip, {\n                                'display': 'block',\n                                'left': mousePos.x / ratio(ctx) + \"px\",\n                                'top': mousePos.y / ratio(ctx) + \"px\"\n                            });\n                        }\n                        chartToolTip.innerHTML = linecord[i].label + ' : ' + linecord[i].y;\n                        break;\n                    }\n                    if (!ctx.isPointInStroke(mousePos.x, mousePos.y)) {\n                        ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                    }\n                }\n            }.bind(this), false);\n\n            canvasUpper.addEventListener('mouseout', function () {\n                setTimeout(function () {\n                    ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                    if (chartToolTip) {\n                        cssStyle(chartToolTip, {\n                            'display': 'none'\n                        });\n                    }\n                }, 2000);\n            });\n        }\n        // console.log(\"End : donutChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in donutChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = DoughnutChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/doughnut_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/line_chart_upper_canvas.js":
/*!**************************************************************!*\
  !*** ./src/common/drawUpperChart/line_chart_upper_canvas.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nconst gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction LineChartUpperCanvas(nr, ctx, linecord, container, chart, maxTextWidth) {\n    try {\n        // console.log(\"Start : lineChartUpperCanvas\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        let dataPointLen = chart.data[0].datapoints.length;\n        let wid = document.getElementById('canvasupper' + nr).width - canvasWidthSpareForDetails;\n        var spacingHorizontal = wid / dataPointLen;\n        let lineCordRepeat = linecord.length / dataPointLen;\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                let details = '';\n                let mousePos = GetMousePos(canvasUpper, evt);\n                for (var i = 0; i < dataPointLen; i++) {\n                    ctx.beginPath();\n                    let x1 = i * spacingHorizontal + canvasWidthSpareForDetails;\n                    let x2 = spacingHorizontal;\n                    let y1 = 0;\n                    let y2 = canvasUpper.height - canvasHeightSpareForDetails;\n                    ctx.rect(x1, y1, x2, y2);\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        for (let j = 0; j < lineCordRepeat; j++) {\n                            ctx.beginPath();\n                            let position = j * dataPointLen + i;\n                            ctx.arc(linecord[position].x, linecord[position].y, 12, 0, 2 * Math.PI);\n                            //ctx.lineWidth = 5;\n                            ctx.strokeStyle = linecord[position].dataColor; //'rgba(0,0,0,.7)';\n                            ctx.fillStyle = linecord[position].dataColor; //'rgba(0,0,0,.7)';\n                            //ctx.stroke();\n                            ctx.fill();\n                            if (chartToolTip) {\n                                cssStyle(chartToolTip, {\n                                    \"left\": mousePos.x / ratio(ctx) + 30 + \"px\",\n                                    \"top\": mousePos.y / ratio(ctx) + \"px\",\n                                    \"display\": \"block\"\n                                });\n                            }\n                            details += `<div style=\"color: ${linecord[position].dataColor}\">${linecord[position].dataLabel}  <br />  ${linecord[position].label} : ${linecord[position].dataval} <br /></div>`;\n                        }\n\n                        ctx.beginPath();\n                        let lineX = x1 + spacingHorizontal / 2;\n                        ctx.setLineDash([5, 15]);\n                        ctx.strokeStyle = strokeStyle;\n                        ctx.lineWidth = 1;\n                        ctx.moveTo(lineX, y1);\n                        ctx.lineTo(lineX, y2);\n                        ctx.stroke();\n\n                        chartToolTip.innerHTML = details;\n                        break;\n                    }\n                    ctx.closePath();\n                }\n            }.bind(this), false);\n        }\n        // console.log(\"End : lineChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in lineChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = LineChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/line_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/pie_chart_upper_canvas.js":
/*!*************************************************************!*\
  !*** ./src/common/drawUpperChart/pie_chart_upper_canvas.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nfunction PieChartUpperCanvas(nr, ctx, linecord, container) {\n    try {\n        // console.log(\"Start : pieChartUpperCanvas\");\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        const canvasUpperHeight = canvasUpper.height;\n        const canvasUpperWidth = canvasUpper.width;\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                let mousePos = GetMousePos(canvasUpper, evt);\n                let lineCordLength = linecord.length;\n                for (var i = 0; i < lineCordLength; i++) {\n                    ctx.beginPath();\n                    ctx.lineTo(linecord[i].wid / 2, linecord[i].hei / 2);\n                    ctx.arc(linecord[i].wid / 2, linecord[i].hei / 2, linecord[i].hei / 2, linecord[i].startangle, linecord[i].lastangle, false);\n                    ctx.lineTo(linecord[i].x, linecord[i].x);\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        ctx.fillStyle = 'rgba(0,0,0,.3)';\n                        ctx.fill();\n                        if (chartToolTip) {\n                            cssStyle(chartToolTip, {\n                                'display': 'block',\n                                'left': mousePos.x / ratio(ctx) + \"px\",\n                                'top': mousePos.y / ratio(ctx) + \"px\"\n                            });\n                            chartToolTip.innerHTML = linecord[i].label + ' : ' + linecord[i].y;\n                        }\n\n                        break;\n                    } else {\n                        ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                    }\n                }\n            }.bind(this), false);\n\n            canvasUpper.addEventListener('mouseout', function (evt) {\n                setTimeout(function () {\n                    ctx.clearRect(0, 0, canvasUpperWidth, canvasUpperHeight);\n                    cssStyle(chartToolTip, {\n                        'display': 'none'\n                    });\n                }, 2000);\n            });\n        }\n        // console.log(\"End : pieChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in pieChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = PieChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/pie_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/stacked_chart_upper_canvas.js":
/*!*****************************************************************!*\
  !*** ./src/common/drawUpperChart/stacked_chart_upper_canvas.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nconst gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction stackedChartUpperCanvas(nr, ctx, lineCord, container, chart, maxTextWidth = 0) {\n    try {\n        // console.log(\"Start : barChartUpperCanvas\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        console.log(lineCord);\n        let dataPointLen = chart.categories.length;\n        let wid = document.getElementById('canvasupper' + nr).width - canvasWidthSpareForDetails;\n        const spacingHorizontal = wid / dataPointLen;\n        let lineCordRepeat = lineCord.length / dataPointLen;\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        const canvasUpperHeight = canvasUpper.height;\n        // const canvasUpperWidth = canvasUpper.width;\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                let mousePos = GetMousePos(canvasUpper, evt);\n                let details = '';\n                for (let i = 0; i < dataPointLen; i++) {\n                    ctx.beginPath();\n                    let x1 = i * spacingHorizontal + canvasWidthSpareForDetails;\n                    let x2 = spacingHorizontal;\n                    let y1 = 0;\n                    let y2 = canvasUpperHeight - canvasHeightSpareForDetails;\n                    ctx.rect(x1, y1, x2, y2);\n\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        ctx.beginPath();\n                        ctx.rect(x1, y1, x2, y2);\n                        ctx.fillStyle = 'rgba(0,0,0,.05)';\n                        ctx.fill();\n                        ctx.closePath();\n                        for (let j = 0; j < lineCordRepeat; j++) {\n                            let position = j * dataPointLen + i;\n                            for (let k = lineCord[position].length - 1; k >= 0; k--) {\n                                const dataPoint = lineCord[position][k];\n                                details += `<div style=\"color: ${dataPoint.dataColor}\">${dataPoint.dataLabel}  \n                                        <br />  ${dataPoint.label} : ${dataPoint.dataVal} <br /></div>`;\n                            }\n                        }\n                        if (chartToolTip) {\n                            cssStyle(chartToolTip, {\n                                \"left\": mousePos.x / ratio(ctx) + 30 + \"px\",\n                                \"top\": mousePos.y / ratio(ctx) + \"px\",\n                                \"display\": \"block\"\n                            });\n                        }\n                        ctx.beginPath();\n                        let lineX = x1 + spacingHorizontal / 2;\n                        ctx.strokeStyle = strokeStyle;\n                        ctx.lineWidth = 1;\n                        ctx.moveTo(lineX, y1);\n                        ctx.stroke();\n                        chartToolTip.innerHTML = details;\n                        break;\n                    }\n                    ctx.closePath();\n                }\n            }.bind(this), false);\n        }\n        // console.log(\"End : barChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in barChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = stackedChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/stacked_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/grid.js":
/*!****************************!*\
  !*** ./src/common/grid.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst xAxisSpacing = gkChartConsts.xAxisSpacing;\nconst fontLineHeight = gkChartConsts.fontLineHeight;\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst blackFillStyle = gkChartConsts.blackFillStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nconst drawGrid = (nr, verticanNr, ctx, data, maxTextWidth = 0) => {\n    try {\n        // console.log(\"Start : drawGrid\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById('canvas' + nr);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        //// console.log(\"canvas height to draw grid lines:\" + hei);\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        //// console.log(\"canvas width to draw grid lines:\" + wid);\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n\n        const spacingVertical = hei / verticanNr;\n        //// console.log(\"canvas vertical spacings to draw grid lines:\" + spacingVertical);\n        const spacingHorizontal = wid / data[0].datapoints.length;\n        //// console.log(\"canvas horizontal spacings to draw grid lines:\" + spacingHorizontal);\n        /*// console.log(spacingVertical + 20);\n         // console.log(wid);*/\n        let barwidth = 0;\n        if (data.length > 1) {\n            barwidth = (spacingHorizontal - 30) / data.length;\n        } else {\n            barwidth = 30;\n        }\n        if (barwidth > 30) {\n            barwidth = 30;\n        }\n        /*Vertical grid*/\n        // Vartical first grid row\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = strokeStyle;\n        ctx.moveTo(canvasWidthSpareForDetails, 0);\n        ctx.lineTo(canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        // vartical other grid rows\n        for (let i = 0; i < data[0].datapoints.length; i++) {\n            ctx.beginPath();\n            ctx.moveTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei);\n            ctx.lineTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei + 10);\n            ctx.stroke();\n        }\n        ctx.beginPath();\n        ctx.moveTo(wid + canvasWidthSpareForDetails, hei);\n        ctx.lineTo(wid + canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        /*Horizontal grid*/\n        for (let i = 0; i < verticanNr + 1; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(0,0,0,.2)';\n            ctx.lineWidth = .6;\n            if (i === parseInt(verticanNr)) {\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = strokeStyle;\n            }\n            ctx.moveTo(canvasWidthSpareForDetails - 10, i * spacingVertical + 1);\n            ctx.lineTo(wid + canvasWidthSpareForDetails, i * spacingVertical + 1);\n            ctx.stroke();\n        }\n        // console.log(\"End : drawGrid\");\n        return barwidth;\n    } catch (e) {\n        console.log(\"error occurred in drawGrid : \", e);\n    }\n};\n\nconst drawGraphicLinearYcord = (canvasId, ctx, verticalNr, cdata, maxTextWidth = 0) => {\n    try {\n        // console.log(\"Start : drawGraphicLinearYcord\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        const spacingHorizontal = wid / cdata.data[0].datapoints.length;\n        //// console.log(spacingHorizontal);\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n        ctx.save();\n        ctx.translate(0, canvas.height / 2);\n        ctx.rotate(-Math.PI / 2);\n        ctx.textAlign = \"center\";\n        if (!cdata.yaxis.title) {\n            cdata.yaxis.title = \"Y-Axis data\";\n        }\n        ctx.fillText(cdata.yaxis.title, 0, 20);\n\n        ctx.restore();\n        /* xaxis Horizontal Documents*/\n        ctx.save();\n        let xangle;\n        for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n            if (ctx.measureText(cdata.data[0].datapoints[i].label).width > spacingHorizontal / 1.1) {\n                xangle = 'angular';\n                break;\n            } else if (ctx.measureText(cdata.data[0].datapoints[i].label).width < spacingHorizontal / 2) {\n                xangle = 'straight';\n            }\n        }\n        if (xangle === 'angular') {\n            const translateXWithoutSpacingHorizontal = xAxisSpacing + spacingHorizontal / 2 - fontLineHeight;\n            const translateYAxis = hei + 12;\n            for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n                const translatexWithSpacing = i * spacingHorizontal + translateXWithoutSpacingHorizontal;\n                ctx.translate(translatexWithSpacing, translateYAxis);\n                ctx.rotate(Math.PI / 2);\n                ctx.fillText(cdata.data[0].datapoints[i].label, 0, 0);\n                //// console.log(cdata.xaxis.categories[i], i*spacingHorizontal, hei-spacingVertical);\n                ctx.rotate(-Math.PI / 2);\n                ctx.translate(-translatexWithSpacing, -translateYAxis);\n            }\n        } else {\n            for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n                let textWidth = ctx.measureText(cdata.data[0].datapoints[i].label).width;\n                let fromLeft = i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails - textWidth / 2;\n                ctx.fillText(cdata.data[0].datapoints[i].label, fromLeft, hei + 35);\n            }\n        }\n        //ctx.restore();\n\n        /* yaxis Vertical Documents*/\n        ctx.save();\n        for (let i = 0; i < verticalNr + 1; i++) {\n            // const max = cdata.yaxis.max;\n            const min = cdata.yaxis.min;\n            const difference = cdata.yaxis.difference;\n            let yAxis = canvas.height - (i * spacingVertical + canvasHeightSpareForDetails);\n            yAxis = i !== verticalNr ? yAxis : yAxis + fontLineHeight;\n            const text = String(Math.floor(i * difference + min));\n            const xAxis = canvasWidthSpareForDetails - ctx.measureText(text).width - 20;\n            ctx.fillText(text, xAxis, yAxis);\n        }\n        //ctx.restore();\n        ctx.closePath();\n        // console.log(\"End : drawGraphicLinearYcord\");\n    } catch (e) {\n        console.log(\"error occurred in drawGraphicLinearYcord : \", e);\n    }\n};\n\nexports.drawGrid = drawGrid;\nexports.drawGraphicLinearYcord = drawGraphicLinearYcord;\n\n//# sourceURL=webpack:///./src/common/grid.js?");

/***/ }),

/***/ "./src/common/grid_new.js":
/*!********************************!*\
  !*** ./src/common/grid_new.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst xAxisSpacing = gkChartConsts.xAxisSpacing;\nconst fontLineHeight = gkChartConsts.fontLineHeight;\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst blackFillStyle = gkChartConsts.blackFillStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nconst drawGridNew = (nr, verticanNr, ctx, data, maxTextWidth = 0) => {\n    try {\n        // console.log(\"Start : drawGrid\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById('canvas' + nr);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n\n        const spacingVertical = hei / verticanNr;\n        const dataCount = data.categories.length;\n        const spacingHorizontal = wid / dataCount;\n\n        /*Vertical grid*/\n        // Vartical first grid row\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = strokeStyle;\n        ctx.moveTo(canvasWidthSpareForDetails, 0);\n        ctx.lineTo(canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        // vartical other grid rows\n        for (let i = 0; i < dataCount; i++) {\n            ctx.beginPath();\n            ctx.moveTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei);\n            ctx.lineTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei + 10);\n            ctx.stroke();\n        }\n        ctx.beginPath();\n        ctx.moveTo(wid + canvasWidthSpareForDetails, hei);\n        ctx.lineTo(wid + canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        /*Horizontal grid*/\n        for (let i = 0; i < verticanNr + 1; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(0,0,0,.2)';\n            ctx.lineWidth = .6;\n            if (i === parseInt(verticanNr)) {\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = strokeStyle;\n            }\n            ctx.moveTo(canvasWidthSpareForDetails - 10, i * spacingVertical + 1);\n            ctx.lineTo(wid + canvasWidthSpareForDetails, i * spacingVertical + 1);\n            ctx.stroke();\n        }\n        // console.log(\"End : drawGrid\");\n    } catch (e) {\n        console.log(\"error occurred in drawGrid : \", e);\n    }\n};\n\nconst drawNewGraphicLinearYCord = (canvasId, ctx, verticalNr, cdata, maxTextWidth = 0) => {\n    try {\n        // console.log(\"Start : drawGraphicLinearYcord\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        const charXAxisLength = cdata.categories.length;\n        const spacingHorizontal = wid / charXAxisLength;\n        //// console.log(spacingHorizontal);\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n        ctx.save();\n        ctx.translate(0, canvas.height / 2);\n        ctx.rotate(-Math.PI / 2);\n        ctx.textAlign = \"center\";\n        if (!cdata.yAxis.title) {\n            cdata.yAxis.title = \"Y-Axis data\";\n        }\n        ctx.fillText(cdata.yAxis.title, 0, 20);\n\n        ctx.restore();\n        /* categories Horizontal Documents*/\n        ctx.save();\n        let xAngle;\n        for (let i = 0; i < charXAxisLength; i++) {\n            if (ctx.measureText(cdata.categories[i].label).width > spacingHorizontal / 1.1) {\n                xAngle = 'angular';\n                break;\n            } else if (ctx.measureText(cdata.categories[i].label).width < spacingHorizontal / 2) {\n                xAngle = 'straight';\n            }\n        }\n        if (xAngle === 'angular') {\n            const translateXWithoutSpacingHorizontal = xAxisSpacing + spacingHorizontal / 2 - fontLineHeight;\n            const translateYAxis = hei + 12;\n            for (let i = 0; i < charXAxisLength; i++) {\n                const translatexWithSpacing = i * spacingHorizontal + translateXWithoutSpacingHorizontal;\n                ctx.translate(translatexWithSpacing, translateYAxis);\n                ctx.rotate(Math.PI / 2);\n                ctx.fillText(cdata.categories[i].label, 0, 0);\n                //// console.log(cdata.xaxis.categories[i], i*spacingHorizontal, hei-spacingVertical);\n                ctx.rotate(-Math.PI / 2);\n                ctx.translate(-translatexWithSpacing, -translateYAxis);\n            }\n        } else {\n            for (let i = 0; i < charXAxisLength; i++) {\n                const text = cdata.categories[i].label;\n                let textWidth = ctx.measureText(text).width;\n                let fromLeft = i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails - textWidth / 2;\n                ctx.fillText(text, fromLeft, hei + 35);\n            }\n        }\n        //ctx.restore();\n\n        /* yAxis Vertical Documents*/\n        ctx.save();\n        const min = cdata.yAxis.min;\n        const difference = cdata.yAxis.difference;\n        for (let i = 0; i < verticalNr + 1; i++) {\n            let yAxis = canvas.height - (i * spacingVertical + canvasHeightSpareForDetails);\n            yAxis = i !== verticalNr ? yAxis : yAxis + fontLineHeight;\n            const text = String(Math.ceil(i * difference + min));\n            const xAxis = canvasWidthSpareForDetails - ctx.measureText(text).width - 20;\n            ctx.fillText(text, xAxis, yAxis);\n        }\n        //ctx.restore();\n        ctx.closePath();\n        // console.log(\"End : drawGraphicLinearYcord\");\n    } catch (e) {\n        console.log(\"error occurred in drawGraphicLinearYcord : \", e);\n    }\n};\n\nexports.drawGridNew = drawGridNew;\nexports.drawNewGraphicLinearYCord = drawNewGraphicLinearYCord;\n\n//# sourceURL=webpack:///./src/common/grid_new.js?");

/***/ }),

/***/ "./src/common/mouse_position.js":
/*!**************************************!*\
  !*** ./src/common/mouse_position.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function GetMousePos(canvas, evt) {\n    try {\n        //// console.log(\"Start : getMousePos\");\n        var rect = canvas.getBoundingClientRect();\n        return {\n            x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,\n            y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height\n        };\n        //// console.log(\"End : getMousePos\");\n    } catch (e) {\n        console.log(\"error occurred in getMousePos : \", e);\n    }\n};\n\nmodule.exports = GetMousePos;\n\n//# sourceURL=webpack:///./src/common/mouse_position.js?");

/***/ }),

/***/ "./src/common/print_content.js":
/*!*************************************!*\
  !*** ./src/common/print_content.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function PrintContent(event, canvasWidth, canvasHeight, chartID) {\n    //// console.log(event);\n    // let elem = event.target.parentNode;\n    let elem = document.getElementById(chartID);\n    let dataUrl = document.querySelector('#' + elem.id + \" canvas\").toDataURL();\n\n    let windowContent = '<!DOCTYPE html>';\n    windowContent += '<html>';\n    windowContent += '<head><title>Print canvas</title></head>';\n    windowContent += '<body>';\n    windowContent += elem.innerHTML;\n    windowContent += '<img width=\"' + canvasWidth + '\" height=\"' + canvasHeight + '\" src=\"' + dataUrl + '\">';\n    windowContent += '</body>';\n    windowContent += '</html>';\n\n    const printWin = window.open('', '', 'width=' + screen.availWidth + ',height=' + screen.availHeight);\n    printWin.document.open();\n    printWin.document.write(windowContent);\n\n    printWin.document.addEventListener('load', function () {\n        printWin.focus();\n        printWin.print();\n        printWin.document.close();\n        printWin.close();\n    }, true);\n};\n\nmodule.exports = PrintContent;\n\n//# sourceURL=webpack:///./src/common/print_content.js?");

/***/ }),

/***/ "./src/common/print_options.js":
/*!*************************************!*\
  !*** ./src/common/print_options.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import Canvas2Image from \"./canvas_to_image\";\nconst Canvas2Image = __webpack_require__(/*! ./canvas_to_image */ \"./src/common/canvas_to_image.js\");\n// import cssStyle from \"./css_style\";\nconst cssStyle = __webpack_require__(/*! ./css_style */ \"./src/common/css_style.js\");\n// import PrintContent from \"./print_content\";\nconst PrintContent = __webpack_require__(/*! ./print_content */ \"./src/common/print_content.js\");\n\nconst printOptions = (chartID, chart) => {\n    try {\n\n        if (chart.config.printEnable != undefined && chart.config.printEnable == true) {\n            let content = `\n                        <div id=\"print-option-menu\" style=\"\n                                        position: absolute;\n                                        right: 25px;\n                                        margin-top:-65px;\n                                        border-radius:4px;\n                                        border:1px solid #000;\n                                        background: rgba(0,0,0,.3);\n                                        cursor:pointer;\">\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                        </div>\n                        <div id=\"print-options\" style=\"display:none;\">\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"print_${chartID}\">Print</div>\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"jpg_${chartID}\">Save as JPEG</div>\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"png_${chartID}\">Save as PNG</div>\n                        </div>\n                        `;\n            return content;\n        }\n        return null;\n    } catch (err) {\n        console.log(\"Error in Print Options\", err);\n    }\n};\n\nconst printAction = (chartID, chart) => {\n    try {\n        if (chart.config.printEnable != undefined && chart.config.printEnable == true) {\n            let visible = false;\n            document.querySelector(`#${chartID} #print-option-menu`).addEventListener('click', function (event) {\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"position\": \"absolute\",\n                    \"right\": \"25px\",\n                    \"border\": \"1px solid #000\",\n                    \"background-color\": \"#fff\",\n                    \"z-index\": \"999\",\n                    \"margin-top\": \"-38px\"\n                });\n                if (!visible) {\n                    cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                        \"display\": \"block\"\n                    });\n                    visible = true;\n                } else {\n                    cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                        \"display\": \"none\"\n                    });\n                    visible = false;\n                }\n            });\n            document.querySelector(\"#\" + chartID + \" #print_\" + chartID).addEventListener('click', function (event) {\n                PrintContent(event, chart.wid, chart.hei, chartID);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n            document.querySelector(\"#\" + chartID + \" #jpg_\" + chartID).addEventListener('click', function (event) {\n                Canvas2Image.saveAsImage(document.getElementById(`canvas${chartID}`), document.getElementById(`canvas${chartID}`).width, document.getElementById(`canvas${chartID}`).height);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n            document.querySelector(\"#\" + chartID + \" #png_\" + chartID).addEventListener('click', function (event) {\n                Canvas2Image.saveAsImage(document.getElementById(`canvas${chartID}`), document.getElementById(`canvas${chartID}`).width, document.getElementById(`canvas${chartID}`).height);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n        }\n    } catch (error) {\n        console.log(error);\n    }\n};\n\nexports.printOptions = printOptions;\nexports.printAction = printAction;\n\n//# sourceURL=webpack:///./src/common/print_options.js?");

/***/ }),

/***/ "./src/common/reatio.js":
/*!******************************!*\
  !*** ./src/common/reatio.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function ratio(ctx) {\n    var dpr = window.devicePixelRatio || 1;\n    var bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n    return 2;\n    //return dpr / bsr;\n}\n\nmodule.exports = ratio;\n\n//# sourceURL=webpack:///./src/common/reatio.js?");

/***/ }),

/***/ "./src/common/vertical-grid.js":
/*!*************************************!*\
  !*** ./src/common/vertical-grid.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst xAxisSpacing = gkChartConsts.xAxisSpacing;\nconst fontLineHeight = gkChartConsts.fontLineHeight;\nconst fontSize = gkChartConsts.font;\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst blackFillStyle = gkChartConsts.blackFillStyle;\nlet canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nlet canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nconst drawVerticalGrid = (nr, horizontalNr, ctx, data, maxTextWidth) => {\n    try {\n        // console.log(\"Start : drawGrid\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById('canvas' + nr);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n\n        const dataCount = data.categories.length;\n        const spacingVertical = hei / dataCount;\n        const spacingHorizontal = wid / horizontalNr;\n\n        /*Vertical grid*/\n\n        // Vertical grid rows\n        for (let i = 0; i < dataCount + 1; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(0,0,0,.5)';\n            ctx.lineWidth = .5;\n            ctx.moveTo(canvasWidthSpareForDetails - 10, i * spacingVertical + 1);\n            ctx.lineTo(wid + canvasWidthSpareForDetails, i * spacingVertical + 1);\n            ctx.closePath();\n        }\n\n        /*Horizontal grid*/\n        for (let i = 0; i < horizontalNr + 1; i++) {\n\n            ctx.beginPath();\n            ctx.lineWidth = .5;\n            ctx.strokeStyle = 'rgba(0,0,0,.5)';\n            ctx.moveTo(i * spacingHorizontal + canvasWidthSpareForDetails - 1, 0);\n            ctx.lineTo(i * spacingHorizontal + canvasWidthSpareForDetails - 1, hei + 10);\n            ctx.stroke();\n            ctx.closePath();\n        }\n        // console.log(\"End : drawGrid\");\n    } catch (e) {\n        console.log(\"error occurred in drawGrid : \", e);\n    }\n};\n\nconst drawDocumentationDetails = (canvasId, ctx, horizontalNr, cdata, maxTextWidth) => {\n    try {\n        // console.log(\"Start : drawGraphicLinearYcord\");\n        if (maxTextWidth > canvasWidthSpareForDetails) {\n            canvasWidthSpareForDetails = maxTextWidth;\n        }\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const categoriesLength = cdata.categories.length;\n        const spacingVertical = hei / categoriesLength;\n        const spacingHorizontal = wid / horizontalNr;\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n\n        /* yAxis data */\n        const spacingTopYAxisText = spacingVertical / 2 + fontLineHeight / 2;\n        for (let i = 0; i < categoriesLength; i++) {\n            let textWidth = ctx.measureText(cdata.categories[i].label).width;\n            let fromLeft = canvasWidthSpareForDetails - textWidth - 10; // extra -10 to give more space after y axis test is written\n            ctx.beginPath();\n            ctx.fillText(cdata.categories[i].label, fromLeft, i * spacingVertical + spacingTopYAxisText);\n            ctx.closePath();\n        }\n\n        /* xAxis Vertical Documents*/\n        for (let i = 0; i < horizontalNr + 1; i++) {\n            const min = cdata.xAxis.min;\n            const difference = cdata.xAxis.difference;\n            const text = String(Math.ceil(i * difference + min));\n            let textWidth = ctx.measureText(text).width;\n            textWidth = i > 0 ? textWidth : 0;\n            ctx.beginPath();\n            ctx.fillText(text, i * spacingHorizontal + canvasWidthSpareForDetails - textWidth, hei + 40);\n            ctx.closePath();\n        }\n        ctx.closePath();\n        // console.log(\"End : drawGraphicLinearYcord\");\n    } catch (e) {\n        console.log(\"error occurred in drawDocumentationDetails : \", e);\n    }\n};\n\nexports.drawVerticalGrid = drawVerticalGrid;\nexports.drawDocumentationDetails = drawDocumentationDetails;\n\n//# sourceURL=webpack:///./src/common/vertical-grid.js?");

/***/ }),

/***/ "./src/invokeCharts/enums.js":
/*!***********************************!*\
  !*** ./src/invokeCharts/enums.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.xAxisSpacing = 104;\nexports.fontLineHeight = 26;\nexports.strokeStyle = \"rgba(0,0,0,1)\";\nexports.white = \"#fff\";\nexports.blackFillStyle = \"#000\";\nexports.canvasHeightSpareForDetails = 105;\nexports.canvasWidthSpareForDetails = 100;\nexports.font = \"26px  Source Sans Pro, Helvetica Neue, Arial, sans-serif\";\nexports.toolTipBgColor = \"rgba(255, 255, 255, .9)\";\n\nexports.barChart = \"bar-chart\";\nexports.columnChart = \"column-chart\";\nexports.lineChart = \"line-chart\";\nexports.stepLineChart = \"step-line-chart\";\nexports.smoothLineChart = \"smooth-line-chart\";\nexports.combinationChart = \"combination-chart\";\nexports.pieChart = \"pie-chart\";\nexports.doughnutChart = \"doughnut-chart\";\nexports.meterChart = \"meter-chart\";\nexports.sparkChart = \"spark-chart\";\nexports.stackedColumnChart = \"stacked-column-chart\";\nexports.stackedBarChart = \"stacked-bar-chart\";\nexports.overlapColumnChart = \"overlap-column-chart\";\nexports.overlapBarChart = \"overlap-bar-chart\";\n\n//# sourceURL=webpack:///./src/invokeCharts/enums.js?");

/***/ })

/******/ });