/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/invokeCharts/line_chart.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/common/canvas_to_image.js":
/*!***************************************!*\
  !*** ./src/common/canvas_to_image.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * covert canvas to image\n * and save the image file\n */\n\nvar Canvas2Image = function () {\n\n    // check if support sth.\n    var $support = function () {\n        var canvas = document.createElement('canvas'),\n            ctx = canvas.getContext('2d');\n\n        return {\n            canvas: !!ctx,\n            imageData: !!ctx.getImageData,\n            dataURL: !!canvas.toDataURL,\n            btoa: !!window.btoa\n        };\n    }();\n\n    var downloadMime = 'image/octet-stream';\n\n    function scaleCanvas(canvas, width, height) {\n        var w = canvas.width,\n            h = canvas.height;\n        if (width == undefined) {\n            width = w;\n        }\n        if (height == undefined) {\n            height = h;\n        }\n\n        var retCanvas = document.createElement('canvas');\n        var retCtx = retCanvas.getContext('2d');\n        retCanvas.width = width;\n        retCanvas.height = height;\n        retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);\n        return retCanvas;\n    }\n\n    function getDataURL(canvas, type, width, height) {\n        canvas = scaleCanvas(canvas, width, height);\n        return canvas.toDataURL(type);\n    }\n\n    function saveFile(strData) {\n        document.location.href = strData;\n    }\n\n    function genImage(strData) {\n        var img = document.createElement('img');\n        img.src = strData;\n        return img;\n    }\n\n    function fixType(type) {\n        type = type.toLowerCase().replace(/jpg/i, 'jpeg');\n        var r = type.match(/png|jpeg|bmp|gif/)[0];\n        return 'image/' + r;\n    }\n\n    function encodeData(data) {\n        if (!window.btoa) {\n            throw 'btoa undefined';\n        }\n        var str = '';\n        if (typeof data == 'string') {\n            str = data;\n        } else {\n            for (var i = 0; i < data.length; i++) {\n                str += String.fromCharCode(data[i]);\n            }\n        }\n\n        return btoa(str);\n    }\n\n    function getImageData(canvas) {\n        var w = canvas.width,\n            h = canvas.height;\n        return canvas.getContext('2d').getImageData(0, 0, w, h);\n    }\n\n    function makeURI(strData, type) {\n        return 'data:' + type + ';base64,' + strData;\n    }\n\n    /**\n     * create bitmap image\n     */\n    var genBitmapImage = function (oData) {\n\n        var biWidth = oData.width;\n        var biHeight = oData.height;\n        var biSizeImage = biWidth * biHeight * 3;\n        var bfSize = biSizeImage + 54; // total header size = 54 bytes\n\n        //\n        //  typedef struct tagBITMAPFILEHEADER {\n        //  \tWORD bfType;\n        //  \tDWORD bfSize;\n        //  \tWORD bfReserved1;\n        //  \tWORD bfReserved2;\n        //  \tDWORD bfOffBits;\n        //  } BITMAPFILEHEADER;\n        //\n        var BITMAPFILEHEADER = [\n        // WORD bfType -- The file type signature; must be \"BM\"\n        0x42, 0x4D,\n        // DWORD bfSize -- The size, in bytes, of the bitmap file\n        bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,\n        // WORD bfReserved1 -- Reserved; must be zero\n        0, 0,\n        // WORD bfReserved2 -- Reserved; must be zero\n        0, 0,\n        // DWORD bfOffBits -- The offset, in bytes, from the beginning of the BITMAPFILEHEADER structure to the bitmap bits.\n        54, 0, 0, 0];\n\n        //\n        //  typedef struct tagBITMAPINFOHEADER {\n        //  \tDWORD biSize;\n        //  \tLONG  biWidth;\n        //  \tLONG  biHeight;\n        //  \tWORD  biPlanes;\n        //  \tWORD  biBitCount;\n        //  \tDWORD biCompression;\n        //  \tDWORD biSizeImage;\n        //  \tLONG  biXPelsPerMeter;\n        //  \tLONG  biYPelsPerMeter;\n        //  \tDWORD biClrUsed;\n        //  \tDWORD biClrImportant;\n        //  } BITMAPINFOHEADER, *PBITMAPINFOHEADER;\n        //\n        var BITMAPINFOHEADER = [\n        // DWORD biSize -- The number of bytes required by the structure\n        40, 0, 0, 0,\n        // LONG biWidth -- The width of the bitmap, in pixels\n        biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,\n        // LONG biHeight -- The height of the bitmap, in pixels\n        biHeight & 0xff, biHeight >> 8 & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,\n        // WORD biPlanes -- The number of planes for the target device. This value must be set to 1\n        1, 0,\n        // WORD biBitCount -- The number of bits-per-pixel, 24 bits-per-pixel -- the bitmap\n        // has a maximum of 2^24 colors (16777216, Truecolor)\n        24, 0,\n        // DWORD biCompression -- The type of compression, BI_RGB (code 0) -- uncompressed\n        0, 0, 0, 0,\n        // DWORD biSizeImage -- The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps\n        biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,\n        // LONG biXPelsPerMeter, unused\n        0, 0, 0, 0,\n        // LONG biYPelsPerMeter, unused\n        0, 0, 0, 0,\n        // DWORD biClrUsed, the number of color indexes of palette, unused\n        0, 0, 0, 0,\n        // DWORD biClrImportant, unused\n        0, 0, 0, 0];\n\n        var iPadding = (4 - biWidth * 3 % 4) % 4;\n\n        var aImgData = oData.data;\n\n        var strPixelData = '';\n        var biWidth4 = biWidth << 2;\n        var y = biHeight;\n        var fromCharCode = String.fromCharCode;\n\n        do {\n            var iOffsetY = biWidth4 * (y - 1);\n            var strPixelRow = '';\n            for (var x = 0; x < biWidth; x++) {\n                var iOffsetX = x << 2;\n                strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) + fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) + fromCharCode(aImgData[iOffsetY + iOffsetX]);\n            }\n\n            for (var c = 0; c < iPadding; c++) {\n                strPixelRow += String.fromCharCode(0);\n            }\n\n            strPixelData += strPixelRow;\n        } while (--y);\n\n        var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);\n\n        return strEncoded;\n    };\n\n    /**\n     * saveAsImage\n     * @param canvasElement\n     * @param {String} image type\n     * @param {Number} [optional] png width\n     * @param {Number} [optional] png height\n     */\n    var saveAsImage = function (canvas, width, height, type) {\n        if ($support.canvas && $support.dataURL) {\n            if (typeof canvas == \"string\") {\n                canvas = document.getElementById(canvas);\n            }\n            if (type == undefined) {\n                type = 'png';\n            }\n            type = fixType(type);\n            if (/bmp/.test(type)) {\n                var data = getImageData(scaleCanvas(canvas, width, height));\n                var strData = genBitmapImage(data);\n                saveFile(makeURI(strData, downloadMime));\n            } else {\n                var strData = getDataURL(canvas, type, width, height);\n                saveFile(strData.replace(type, downloadMime));\n            }\n        }\n    };\n\n    var convertToImage = function (canvas, width, height, type) {\n        if ($support.canvas && $support.dataURL) {\n            if (typeof canvas == \"string\") {\n                canvas = document.getElementById(canvas);\n            }\n            if (type == undefined) {\n                type = 'png';\n            }\n            type = fixType(type);\n\n            if (/bmp/.test(type)) {\n                var data = getImageData(scaleCanvas(canvas, width, height));\n                var strData = genBitmapImage(data);\n                return genImage(makeURI(strData, 'image/bmp'));\n            } else {\n                var strData = getDataURL(canvas, type, width, height);\n                return genImage(strData);\n            }\n        }\n    };\n\n    return {\n        saveAsImage: saveAsImage,\n        saveAsPNG: function (canvas, width, height) {\n            return saveAsImage(canvas, width, height, 'png');\n        },\n        saveAsJPEG: function (canvas, width, height) {\n            return saveAsImage(canvas, width, height, 'jpeg');\n        }\n        // saveAsGIF: function (canvas, width, height) {\n        //   return saveAsImage(canvas, width, height, 'gif');\n        // },\n        // saveAsBMP: function (canvas, width, height) {\n        //   return saveAsImage(canvas, width, height, 'bmp');\n        // },\n\n        // convertToImage: convertToImage,\n        // convertToPNG: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'png');\n        // },\n        // convertToJPEG: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'jpeg');\n        // },\n        // convertToGIF: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'gif');\n        // },\n        // convertToBMP: function (canvas, width, height) {\n        //   return convertToImage(canvas, width, height, 'bmp');\n        // }\n    };\n};\n\nmodule.exports = Canvas2Image;\n\n//# sourceURL=webpack:///./src/common/canvas_to_image.js?");

/***/ }),

/***/ "./src/common/chart_surface.js":
/*!*************************************!*\
  !*** ./src/common/chart_surface.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartEnums = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\nconst font = gkChartEnums.font;\n\nclass ChartSurface {\n\n    ratio(canvasContainer) {\n        // let ctx = canvasContainer.getContext('2d');\n        // let dpr = window.devicePixelRatio || 1;\n        // let bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n        // return dpr / bsr;\n        return 2;\n    }\n\n    prepSurface(nr, width, height, containerId) {\n        try {\n            // console.log(\"Start : prepSurface\");\n            const canvas = document.createElement(\"CANVAS\");\n            canvas.id = 'canvas' + nr;\n            canvas.setAttribute('class', 'canvas');\n            canvas.setAttribute(\"style\", \"position:absolute\");\n            const container = document.getElementById(containerId);\n            container.appendChild(canvas);\n\n            const canvasDom = document.getElementById('canvas' + nr);\n            canvasDom.width = width * this.ratio(canvasDom);\n            canvasDom.height = height * this.ratio(canvasDom);\n            canvasDom.style.width = width + \"px\";\n            canvasDom.style.height = height + \"px\";\n\n            // document.getElementById('container').append('<canvas id=\"canvas' + nr + '\" class=\"canvas\"' +\n            //     ' style=\"position:absolute;\" width=\"' + width + '\" height=\"' + height + '\"></canvas> ');\n            // console.log(\"End : prepSurface\");\n        } catch (e) {\n            console.log(\"error occurred in prepareSurface : \", e);\n        }\n    }\n\n    prepUI(nr) {\n        try {\n            // console.log(\"Start : prepUI\");\n            //// console.log(nr);\n            const canvas = document.getElementById('canvas' + nr);\n            const ctx = canvas.getContext('2d');\n            ctx.font = font;\n            ctx.lineWidth = 1;\n            // console.log(\"End : prepUI\");\n            return ctx;\n        } catch (e) {\n            console.log(\"error occurred in prepUI : \", e);\n        }\n    }\n\n    preparePlot(nr, sizex, sizey, container) {\n        try {\n            // console.log(\"Start : preparePlot\");\n            this.prepSurface(nr, sizex, sizey, container);\n            const canvasContext = this.prepUI(nr);\n            // console.log(\"End : preparePlot\");\n            return canvasContext;\n        } catch (e) {\n            console.log(\"error occurred in preparePlot : \", e);\n        }\n    }\n\n    prepSurfaceupper(nr, width, height, containerId) {\n        try {\n            // console.log(\"Start : prepSurfaceupper\");\n            const container = document.getElementById(containerId);\n            let innerCotent = `<canvas id=\"canvasupper${nr}\" class=\"canvas\" style=\"position:absolute;\"\n                    width=\"${width}\" height=\"${height}\"> </canvas>\n                <div class=\"canvasjs-chart-tooltip\" style=\"position:absolute;height:auto;\n                    box-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 2px 2px; z-index: 1000; display: none; \n                    border-radius: 3px; transition: left 0.2s ease-out, bottom 0.2s ease-out; pointer-events: none;\n                    background-color: rgba(0,0, 0, .8); border: 1px solid rgba(0,0,0,.5); padding: 5px;color: #fff\">\n                        <span style=\"color:#7F6084;\"> </span>\n                </div>`;\n            container.insertAdjacentHTML('beforeend', innerCotent);\n\n            let canvasDom = document.getElementById('canvasupper' + nr);\n            canvasDom.width = width * this.ratio(canvasDom);\n            canvasDom.height = height * this.ratio(canvasDom);\n            canvasDom.style.width = width + \"px\";\n            canvasDom.style.height = height + \"px\";\n\n            // console.log(\"End : prepSurfaceupper\");\n        } catch (e) {\n            console.log(\"error occurred in prepSurfaceupper : \", e);\n        }\n    }\n\n    prepUIUpper(nr) {\n        try {\n            // console.log(\"Start : prepUIUpper\");\n            const canvas = document.getElementById('canvasupper' + nr);\n            const ctx = canvas.getContext('2d');\n            //ctx.font = '18px Arial';\n            ctx.lineWidth = 1;\n            // console.log(\"End : prepUIUpper\");\n            return ctx;\n        } catch (e) {\n            console.log(\"error occurred in prepUIUpper : \", e);\n        }\n    }\n\n    preparePlotUpper(nr, sizex, sizey, container) {\n        try {\n            // console.log(\"Start : preparePlotUpper\");\n            this.prepSurfaceupper(nr, sizex, sizey, container);\n            const canvasContext = this.prepUIUpper(nr);\n            // console.log(\"End : preparePlotUpper\");\n            return canvasContext;\n        } catch (e) {\n            console.log(\"error occurred in preparePlotUpper : \", e);\n        }\n    }\n}\n\nmodule.exports = ChartSurface;\n\n//# sourceURL=webpack:///./src/common/chart_surface.js?");

/***/ }),

/***/ "./src/common/css_style.js":
/*!*********************************!*\
  !*** ./src/common/css_style.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function cssStyle(el, styles) {\n    for (var property in styles) {\n        el.style[property] = styles[property];\n    }\n}\n\nmodule.exports = cssStyle;\n\n//# sourceURL=webpack:///./src/common/css_style.js?");

/***/ }),

/***/ "./src/common/drawChart/line_chart_canvas.js":
/*!***************************************************!*\
  !*** ./src/common/drawChart/line_chart_canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nconst canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction drawLineChart(canvasId, ctx, verticalNr, data, range, chartColor, linecord) {\n    try {\n        // console.log(\"Start : drawGraphicLinear\");\n        const commonCodeCircle = () => {\n            ctx.beginPath();\n            ctx.fillStyle = chartColor;\n            ctx.arc(points[t].x, points[t].y, 8, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n        };\n\n        const fillAreaCall = vertices => {\n            ctx.beginPath();\n            if (vertices.length) {\n                ctx.moveTo(vertices[0].x, hei);\n            }\n            for (let points = 0; points < vertices.length; points++) {\n                ctx.lineTo(vertices[points].x, vertices[points].y + 4);\n            }\n            if (vertices.length) {\n                ctx.lineTo(vertices[vertices.length - 1].x, hei);\n            }\n            ctx.closePath();\n            ctx.globalAlpha = 0.1;\n            ctx.fillStyle = chartColor;\n            ctx.fill();\n        };\n\n        const calcWayPoints = vertices => {\n            let wayPoints = [];\n            for (let i = 1; i < vertices.length; i++) {\n                let pt0 = vertices[i - 1];\n                let pt1 = vertices[i];\n                let dx = pt1.x - pt0.x;\n                let dy = pt1.y - pt0.y;\n                for (let j = 0; j < differencePoints; j++) {\n                    let x = pt0.x + dx * j / differencePoints;\n                    let y = pt0.y + dy * j / differencePoints;\n                    wayPoints.push({\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n            return wayPoints;\n        };\n\n        const animate = () => {\n            if (t < points.length - 1) {\n                requestAnimationFrame(animate);\n            }\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = chartColor;\n            if (t === 0) {\n                ctx.moveTo(points[t].x, points[t].y);\n            } else {\n                ctx.moveTo(points[t - 1].x, points[t - 1].y);\n                ctx.lineTo(points[t].x, points[t].y);\n            }\n            ctx.stroke();\n            // increment \"t\" to get the next waypoint\n            if (t % differencePoints === 0 || t === points.length - 1) {\n                commonCodeCircle();\n            }\n            if (data.fill) {\n                let p = {};\n                if (t) {\n                    p = points.slice(t - 1, t + 1);\n                }\n                fillAreaCall(p);\n            }\n            t += 1;\n        };\n\n        var canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        const spacingHorizontal = wid / data.datapoints.length;\n\n        const totalRange = range[1] - range[0];\n        const verticalCoefficient = hei / totalRange;\n        ctx.beginPath();\n        const localLineCords = [];\n        for (let i = 0; i < data.datapoints.length; i++) {\n            let newObj = {\n                x: i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails,\n                y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient,\n                label: data.datapoints[i].label,\n                dataLabel: data.dataLabel,\n                dataval: data.datapoints[i].y,\n                dataColor: data.chartColor\n            };\n            // This linecord contains multiple charts data ponts for the visualization purpose of on hover.\n            linecord.push(newObj);\n            localLineCords.push(newObj);\n        }\n        let t = 0;\n        let differencePoints = 25;\n        let points = calcWayPoints(localLineCords);\n\n        points.push(localLineCords[localLineCords.length - 1]);\n\n        animate();\n\n        ctx.globalAlpha = 1;\n        return linecord;\n    } catch (e) {\n        console.log(\"error occured in drawGraphicLinear : \", e);\n    }\n}\n\nmodule.exports = drawLineChart;\n\n//# sourceURL=webpack:///./src/common/drawChart/line_chart_canvas.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/clear_upper_canvas_details.js":
/*!*****************************************************************!*\
  !*** ./src/common/drawUpperChart/clear_upper_canvas_details.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n\nfunction ClearDetails(nr, ctx, container) {\n    const canvasUpperNr = document.getElementById('canvasupper' + nr);\n    if (canvasUpperNr) {\n        canvasUpperNr.addEventListener('mousemove', function (evt) {\n            ctx.clearRect(0, 0, canvasUpperNr.width, canvasUpperNr.height);\n        }.bind(this));\n\n        canvasUpperNr.addEventListener('mouseout', function (evt) {\n            setTimeout(function () {\n                ctx.clearRect(0, 0, canvasUpperNr.width, canvasUpperNr.height);\n                const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n                if (chartToolTip) {\n                    cssStyle(chartToolTip, {\n                        'display': 'none'\n                    });\n                }\n            }, 2000);\n        }.bind(this));\n    }\n}\n\nmodule.exports = ClearDetails;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/clear_upper_canvas_details.js?");

/***/ }),

/***/ "./src/common/drawUpperChart/line_chart_upper_canvas.js":
/*!**************************************************************!*\
  !*** ./src/common/drawUpperChart/line_chart_upper_canvas.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import GetMousePos from \"../mouse_position\";\nconst GetMousePos = __webpack_require__(/*! ../mouse_position */ \"./src/common/mouse_position.js\");\n// import cssStyle from \"../css_style\";\nconst cssStyle = __webpack_require__(/*! ../css_style */ \"./src/common/css_style.js\");\n// import ratio from \"../reatio\";\nconst ratio = __webpack_require__(/*! ../reatio */ \"./src/common/reatio.js\");\n\nconst gkChartConsts = __webpack_require__(/*! ../../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nconst canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nfunction LineChartUpperCanvas(nr, ctx, linecord, container, chart) {\n    try {\n        // console.log(\"Start : lineChartUpperCanvas\");\n        let dataPointLen = chart.data[0].datapoints.length;\n        let wid = document.getElementById('canvasupper' + nr).width - canvasWidthSpareForDetails;\n        var spacingHorizontal = wid / dataPointLen;\n        let lineCordRepeat = linecord.length / dataPointLen;\n        const canvasUpper = document.getElementById('canvasupper' + nr);\n        const chartToolTip = document.querySelector('#' + container + ' .canvasjs-chart-tooltip');\n        if (canvasUpper) {\n            canvasUpper.addEventListener('mousemove', function (evt) {\n                let details = '';\n                let mousePos = GetMousePos(canvasUpper, evt);\n                for (var i = 0; i < dataPointLen; i++) {\n                    ctx.beginPath();\n                    let x1 = i * spacingHorizontal + canvasWidthSpareForDetails;\n                    let x2 = spacingHorizontal;\n                    let y1 = 0;\n                    let y2 = canvasUpper.height - canvasHeightSpareForDetails;\n                    ctx.rect(x1, y1, x2, y2);\n                    if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {\n                        for (let j = 0; j < lineCordRepeat; j++) {\n                            ctx.beginPath();\n                            let position = j * dataPointLen + i;\n                            ctx.arc(linecord[position].x, linecord[position].y, 12, 0, 2 * Math.PI);\n                            //ctx.lineWidth = 5;\n                            ctx.strokeStyle = linecord[position].dataColor; //'rgba(0,0,0,.7)';\n                            ctx.fillStyle = linecord[position].dataColor; //'rgba(0,0,0,.7)';\n                            //ctx.stroke();\n                            ctx.fill();\n                            if (chartToolTip) {\n                                cssStyle(chartToolTip, {\n                                    \"left\": mousePos.x / ratio(ctx) + 30 + \"px\",\n                                    \"top\": mousePos.y / ratio(ctx) + \"px\",\n                                    \"display\": \"block\"\n                                });\n                            }\n                            details += `<div style=\"color: ${linecord[position].dataColor}\">${linecord[position].dataLabel}  <br />  ${linecord[position].label} : ${linecord[position].dataval} <br /></div>`;\n                        }\n\n                        ctx.beginPath();\n                        let lineX = x1 + spacingHorizontal / 2;\n                        ctx.setLineDash([5, 15]);\n                        ctx.strokeStyle = strokeStyle;\n                        ctx.lineWidth = 1;\n                        ctx.moveTo(lineX, y1);\n                        ctx.lineTo(lineX, y2);\n                        ctx.stroke();\n\n                        chartToolTip.innerHTML = details;\n                        break;\n                    }\n                    ctx.closePath();\n                }\n            }.bind(this), false);\n        }\n        // console.log(\"End : lineChartUpperCanvas\");\n    } catch (e) {\n        console.log(\"error occurred in lineChartUpperCanvas : \", e);\n    }\n}\n\nmodule.exports = LineChartUpperCanvas;\n\n//# sourceURL=webpack:///./src/common/drawUpperChart/line_chart_upper_canvas.js?");

/***/ }),

/***/ "./src/common/grid.js":
/*!****************************!*\
  !*** ./src/common/grid.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gkChartConsts = __webpack_require__(/*! ../invokeCharts/enums */ \"./src/invokeCharts/enums.js\");\n\nconst xAxisSpacing = gkChartConsts.xAxisSpacing;\nconst fontLineHeight = gkChartConsts.fontLineHeight;\nconst strokeStyle = gkChartConsts.strokeStyle;\nconst blackFillStyle = gkChartConsts.blackFillStyle;\nconst canvasHeightSpareForDetails = gkChartConsts.canvasHeightSpareForDetails;\nconst canvasWidthSpareForDetails = gkChartConsts.canvasWidthSpareForDetails;\n\nconst drawGrid = (nr, verticanNr, ctx, data) => {\n    try {\n        // console.log(\"Start : drawGrid\");\n        const canvas = document.getElementById('canvas' + nr);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        //// console.log(\"canvas height to draw grid lines:\" + hei);\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        //// console.log(\"canvas width to draw grid lines:\" + wid);\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n\n        const spacingVertical = hei / verticanNr;\n        //// console.log(\"canvas vertical spacings to draw grid lines:\" + spacingVertical);\n        const spacingHorizontal = wid / data[0].datapoints.length;\n        //// console.log(\"canvas horizontal spacings to draw grid lines:\" + spacingHorizontal);\n        /*// console.log(spacingVertical + 20);\n         // console.log(wid);*/\n        let barwidth = 0;\n        if (data.length > 1) {\n            barwidth = (spacingHorizontal - 30) / data.length;\n        } else {\n            barwidth = 30;\n        }\n        if (barwidth > 30) {\n            barwidth = 30;\n        }\n        /*Vertical grid*/\n        // Vartical first grid row\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = strokeStyle;\n        ctx.moveTo(canvasWidthSpareForDetails, 0);\n        ctx.lineTo(canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        // vartical other grid rows\n        for (let i = 0; i < data[0].datapoints.length; i++) {\n            ctx.beginPath();\n            ctx.moveTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei);\n            ctx.lineTo(i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails, hei + 10);\n            ctx.stroke();\n        }\n        ctx.beginPath();\n        ctx.moveTo(wid + canvasWidthSpareForDetails, hei);\n        ctx.lineTo(wid + canvasWidthSpareForDetails, hei + 10);\n        ctx.stroke();\n\n        /*Horizontal grid*/\n        for (let i = 0; i < verticanNr + 1; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(0,0,0,.2)';\n            ctx.lineWidth = .4;\n            if (i === parseInt(verticanNr)) {\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = strokeStyle;\n            }\n            ctx.moveTo(canvasWidthSpareForDetails - 10, i * spacingVertical);\n            ctx.lineTo(wid + canvasWidthSpareForDetails, i * spacingVertical);\n            ctx.stroke();\n            ctx.strokeStyle = 'rgba(0,0,0,.2)';\n        }\n        // console.log(\"End : drawGrid\");\n        return barwidth;\n    } catch (e) {\n        console.log(\"error occurred in drawGrid : \", e);\n    }\n};\n\nconst drawGraphicLinearYcord = (canvasId, ctx, verticalNr, cdata) => {\n    try {\n        // console.log(\"Start : drawGraphicLinearYcord\");\n        //// console.log(cdata);\n        const canvas = document.getElementById(canvasId);\n        const hei = canvas.height - canvasHeightSpareForDetails;\n        const wid = canvas.width - canvasWidthSpareForDetails;\n        const spacingVertical = hei / verticalNr;\n        const spacingHorizontal = wid / cdata.data[0].datapoints.length;\n        //// console.log(spacingHorizontal);\n        ctx.beginPath();\n        ctx.fillStyle = blackFillStyle;\n        ctx.save();\n        ctx.translate(0, canvas.height / 2);\n        ctx.rotate(-Math.PI / 2);\n        ctx.textAlign = \"center\";\n        if (!cdata.yaxis.title) {\n            cdata.yaxis.title = \"Y-Axis data\";\n        }\n        ctx.fillText(cdata.yaxis.title, 0, 20);\n\n        ctx.restore();\n        /* xaxis Horizontal Documents*/\n        ctx.save();\n        let xangle;\n        for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n            if (ctx.measureText(cdata.data[0].datapoints[i].label).width > spacingHorizontal / 1.1) {\n                xangle = 'angular';\n                break;\n            } else if (ctx.measureText(cdata.data[0].datapoints[i].label).width < spacingHorizontal / 2) {\n                xangle = 'straight';\n            }\n        }\n        if (xangle === 'angular') {\n            const translateXWithoutSpacingHorizontal = xAxisSpacing + spacingHorizontal / 2 - fontLineHeight;\n            const translateYAxis = hei + 12;\n            for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n                const translatexWithSpacing = i * spacingHorizontal + translateXWithoutSpacingHorizontal;\n                ctx.translate(translatexWithSpacing, translateYAxis);\n                ctx.rotate(Math.PI / 2);\n                ctx.fillText(cdata.data[0].datapoints[i].label, 0, 0);\n                //// console.log(cdata.xaxis.categories[i], i*spacingHorizontal, hei-spacingVertical);\n                ctx.rotate(-Math.PI / 2);\n                ctx.translate(-translatexWithSpacing, -translateYAxis);\n            }\n        } else {\n            for (let i = 0; i < cdata.data[0].datapoints.length; i++) {\n                let textWidth = ctx.measureText(cdata.data[0].datapoints[i].label).width;\n                let fromLeft = i * spacingHorizontal + spacingHorizontal / 2 + canvasWidthSpareForDetails - textWidth / 2;\n                ctx.fillText(cdata.data[0].datapoints[i].label, fromLeft, hei + 35);\n            }\n        }\n        //ctx.restore();\n\n        /* yaxis Vertical Documents*/\n        ctx.save();\n        for (let i = 0; i < verticalNr + 1; i++) {\n            // const max = cdata.yaxis.max;\n            const min = cdata.yaxis.min;\n            const difference = cdata.yaxis.difference;\n            ctx.fillText(i * difference + min, 35, canvas.height - (i * spacingVertical + canvasHeightSpareForDetails));\n        }\n        //ctx.restore();\n        ctx.closePath();\n        // console.log(\"End : drawGraphicLinearYcord\");\n    } catch (e) {\n        console.log(\"error occurred in drawGraphicLinearYcord : \", e);\n    }\n};\n\nexports.drawGrid = drawGrid;\nexports.drawGraphicLinearYcord = drawGraphicLinearYcord;\n\n//# sourceURL=webpack:///./src/common/grid.js?");

/***/ }),

/***/ "./src/common/mouse_position.js":
/*!**************************************!*\
  !*** ./src/common/mouse_position.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function GetMousePos(canvas, evt) {\n    try {\n        //// console.log(\"Start : getMousePos\");\n        var rect = canvas.getBoundingClientRect();\n        return {\n            x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,\n            y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height\n        };\n        //// console.log(\"End : getMousePos\");\n    } catch (e) {\n        console.log(\"error occurred in getMousePos : \", e);\n    }\n};\n\nmodule.exports = GetMousePos;\n\n//# sourceURL=webpack:///./src/common/mouse_position.js?");

/***/ }),

/***/ "./src/common/print_content.js":
/*!*************************************!*\
  !*** ./src/common/print_content.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function PrintContent(event, canvasWidth, canvasHeight, chartID) {\n    //// console.log(event);\n    // let elem = event.target.parentNode;\n    let elem = document.getElementById(chartID);\n    let dataUrl = document.querySelector('#' + elem.id + \" canvas\").toDataURL();\n\n    let windowContent = '<!DOCTYPE html>';\n    windowContent += '<html>';\n    windowContent += '<head><title>Print canvas</title></head>';\n    windowContent += '<body>';\n    windowContent += elem.innerHTML;\n    windowContent += '<img width=\"' + canvasWidth + '\" height=\"' + canvasHeight + '\" src=\"' + dataUrl + '\">';\n    windowContent += '</body>';\n    windowContent += '</html>';\n\n    const printWin = window.open('', '', 'width=' + screen.availWidth + ',height=' + screen.availHeight);\n    printWin.document.open();\n    printWin.document.write(windowContent);\n\n    printWin.document.addEventListener('load', function () {\n        printWin.focus();\n        printWin.print();\n        printWin.document.close();\n        printWin.close();\n    }, true);\n};\n\nmodule.exports = PrintContent;\n\n//# sourceURL=webpack:///./src/common/print_content.js?");

/***/ }),

/***/ "./src/common/print_options.js":
/*!*************************************!*\
  !*** ./src/common/print_options.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import Canvas2Image from \"./canvas_to_image\";\nconst Canvas2Image = __webpack_require__(/*! ./canvas_to_image */ \"./src/common/canvas_to_image.js\");\n// import cssStyle from \"./css_style\";\nconst cssStyle = __webpack_require__(/*! ./css_style */ \"./src/common/css_style.js\");\n// import PrintContent from \"./print_content\";\nconst PrintContent = __webpack_require__(/*! ./print_content */ \"./src/common/print_content.js\");\n\nconst printOptions = (chartID, chart) => {\n    try {\n\n        if (chart.config.printEnable != undefined && chart.config.printEnable == true) {\n            let content = `\n                        <div id=\"print-option-menu\" style=\"\n                                        position: absolute;\n                                        right: 25px;\n                                        margin-top:-65px;\n                                        border-radius:4px;\n                                        border:1px solid #000;\n                                        background: rgba(0,0,0,.3);\n                                        cursor:pointer;\">\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                          <div style=\"width:30px\">\n                            <hr style=\"margin: 5px;\" />\n                          </div>\n                        </div>\n                        <div id=\"print-options\" style=\"display:none;\">\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"print_${chartID}\">Print</div>\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"jpg_${chartID}\">Save as JPEG</div>\n                          <div style=\" padding: 3px 5px;cursor: pointer;\" id=\"png_${chartID}\">Save as PNG</div>\n                        </div>\n                        `;\n            return content;\n        }\n        return null;\n    } catch (err) {\n        console.log(\"Error in Print Options\", err);\n    }\n};\n\nconst printAction = (chartID, chart) => {\n    try {\n        if (chart.config.printEnable != undefined && chart.config.printEnable == true) {\n            let visible = false;\n            document.querySelector(`#${chartID} #print-option-menu`).addEventListener('click', function (event) {\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"position\": \"absolute\",\n                    \"right\": \"25px\",\n                    \"border\": \"1px solid #000\",\n                    \"background-color\": \"#fff\",\n                    \"z-index\": \"999\",\n                    \"margin-top\": \"-38px\"\n                });\n                if (!visible) {\n                    cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                        \"display\": \"block\"\n                    });\n                    visible = true;\n                } else {\n                    cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                        \"display\": \"none\"\n                    });\n                    visible = false;\n                }\n            });\n            document.querySelector(\"#\" + chartID + \" #print_\" + chartID).addEventListener('click', function (event) {\n                PrintContent(event, chart.wid, chart.hei, chartID);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n            document.querySelector(\"#\" + chartID + \" #jpg_\" + chartID).addEventListener('click', function (event) {\n                Canvas2Image.saveAsImage(document.getElementById(`canvas${chartID}`), document.getElementById(`canvas${chartID}`).width, document.getElementById(`canvas${chartID}`).height);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n            document.querySelector(\"#\" + chartID + \" #png_\" + chartID).addEventListener('click', function (event) {\n                Canvas2Image.saveAsImage(document.getElementById(`canvas${chartID}`), document.getElementById(`canvas${chartID}`).width, document.getElementById(`canvas${chartID}`).height);\n                cssStyle(document.querySelector(`#${chartID} #print-options`), {\n                    \"display\": \"none\"\n                });\n                visible = false;\n            });\n        }\n    } catch (error) {\n        console.log(error);\n    }\n};\n\nexports.printOptions = printOptions;\nexports.printAction = printAction;\n\n//# sourceURL=webpack:///./src/common/print_options.js?");

/***/ }),

/***/ "./src/common/reatio.js":
/*!******************************!*\
  !*** ./src/common/reatio.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function ratio(ctx) {\n    var dpr = window.devicePixelRatio || 1;\n    var bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n    return 2;\n    //return dpr / bsr;\n}\n\nmodule.exports = ratio;\n\n//# sourceURL=webpack:///./src/common/reatio.js?");

/***/ }),

/***/ "./src/invokeCharts/enums.js":
/*!***********************************!*\
  !*** ./src/invokeCharts/enums.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.xAxisSpacing = 104;\nexports.fontLineHeight = 16;\nexports.strokeStyle = \"rgba(0,0,0,1)\";\nexports.white = \"#fff\";\nexports.blackFillStyle = \"#000\";\nexports.canvasHeightSpareForDetails = 105;\nexports.canvasWidthSpareForDetails = 100;\nexports.font = \"26px  Source Sans Pro\";\n\nexports.barChart = \"bar-chart\";\nexports.columnChart = \"column-chart\";\nexports.lineChart = \"line-chart\";\nexports.stepLineChart = \"step-line-chart\";\nexports.smoothLineChart = \"smooth-line-chart\";\nexports.multiRandomChart = \"multi-random\";\nexports.pieChart = \"pie-chart\";\nexports.doughnutChart = \"doughnut-chart\";\nexports.meterChart = \"meter-chart\";\n\n//# sourceURL=webpack:///./src/invokeCharts/enums.js?");

/***/ }),

/***/ "./src/invokeCharts/line_chart.js":
/*!****************************************!*\
  !*** ./src/invokeCharts/line_chart.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import { printOptions, printAction } from \"../common/print_options\";\nconst printOpts = __webpack_require__(/*! ../common/print_options */ \"./src/common/print_options.js\");\nconst printOptions = printOpts.printOptions;\nconst printAction = printOpts.printAction;\n// import ChartSurface from \"../common/chart_surface\";\nconst ChartSurface = __webpack_require__(/*! ../common/chart_surface */ \"./src/common/chart_surface.js\");\n// import { drawGrid, drawGraphicLinearYcord } from \"../common/grid\";\nconst Grid = __webpack_require__(/*! ../common/grid */ \"./src/common/grid.js\");\nconst drawGrid = Grid.drawGrid;\nconst drawGraphicLinearYcord = Grid.drawGraphicLinearYcord;\n// import drawLineChart from \"../common/drawChart/line_chart_canvas\";\nconst drawLineChart = __webpack_require__(/*! ../common/drawChart/line_chart_canvas */ \"./src/common/drawChart/line_chart_canvas.js\");\n// import LineChartUpperCanvas from \"../common/drawUpperChart/line_chart_upper_canvas\";\nconst LineChartUpperCanvas = __webpack_require__(/*! ../common/drawUpperChart/line_chart_upper_canvas */ \"./src/common/drawUpperChart/line_chart_upper_canvas.js\");\n// import ClearDetails from \"../common/drawUpperChart/clear_upper_canvas_details\";\nconst ClearDetails = __webpack_require__(/*! ../common/drawUpperChart/clear_upper_canvas_details */ \"./src/common/drawUpperChart/clear_upper_canvas_details.js\");\n\nconst GkLineChart = data => {\n    try {\n        // console.log(\"Start : lineChart\");\n        const chartSurface = new ChartSurface();\n\n        let chartID = data.id;\n        let chart = data.data;\n\n        chart.container = chartID;\n        chart.chartnumber = chartID;\n        let ChartContainer = document.querySelector(\"#\" + chart.container);\n        chart.wid = ChartContainer.clientWidth - 10;\n        chart.hei = ChartContainer.clientHeight - 33;\n\n        let titleAndPrintButton = '';\n        if (chart.config.title) {\n            titleAndPrintButton += '<h2 class=\"chartTitle\">' + chart.config.title + '</h2>';\n        }\n        titleAndPrintButton += printOptions(chartID, chart);\n        ChartContainer.innerHTML = titleAndPrintButton;\n\n        let ctx_base = chartSurface.preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        chart.yaxis === undefined ? chart.yaxis = {} : null;\n        if (chart.yaxis.max === undefined && chart.yaxis.min === undefined) {\n            chart.yaxis.max = parseInt(chart.data[0].datapoints[0].y);\n            chart.yaxis.min = parseInt(chart.data[0].datapoints[0].y);\n            for (let i = 0; i < chart.data.length; i++) {\n                for (let j = 0; j < chart.data[i].datapoints.length; j++) {\n                    if (parseInt(chart.data[i].datapoints[j].y) < chart.yaxis.min) {\n                        chart.yaxis.min = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                    if (parseInt(chart.data[i].datapoints[j].y) > chart.yaxis.max) {\n                        chart.yaxis.max = parseInt(chart.data[i].datapoints[j].y);\n                    }\n                }\n            }\n            chart.yaxis.max += 10;\n            chart.yaxis.min >= 10 ? chart.yaxis.min += -10 : null;\n        }\n        if (chart.yaxis.difference === undefined) {\n            chart.yaxis.difference = Math.floor((chart.yaxis.max - chart.yaxis.min) / 8);\n        }\n        let verticaldevisions = Math.floor((chart.yaxis.max - chart.yaxis.min) / chart.yaxis.difference);\n        drawGrid(chart.chartnumber, verticaldevisions, ctx_base, chart.data);\n        let canvas = 'canvas' + chart.chartnumber;\n        let maxdata = [chart.yaxis.min, chart.yaxis.max];\n        let linecord = [];\n        for (let i = 0; i < chart.data.length; i++) {\n            drawLineChart(canvas, ctx_base, verticaldevisions, chart.data[i], maxdata, chart.data[i].chartColor, linecord);\n        }\n\n        drawGraphicLinearYcord(canvas, ctx_base, verticaldevisions, chart);\n        let ctx_upper = chartSurface.preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);\n        ClearDetails(chart.chartnumber, ctx_upper, chart.container);\n        LineChartUpperCanvas(chart.chartnumber, ctx_upper, linecord, chart.container, chart);\n        printAction(chartID, chart);\n    } catch (err) {\n        console.error(\"Exception occurred in line chart module:  \" + err.message);\n    }\n};\n\nmodule.exports = GkLineChart;\n\n//# sourceURL=webpack:///./src/invokeCharts/line_chart.js?");

/***/ })

/******/ });